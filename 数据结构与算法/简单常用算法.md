# 字符串搜索子串

## 串的朴素模板匹配算法

从 abcde 中匹配 cd:

1. index=0;
   1. a==c,false,break
2. index=1:
   1. b==c,false,break
3. index=2:
   1. c==c,true
   2. d==d,true
   3. cd 完全匹配,return 2

```java
/**
     * 算法思想:
     * str index=0 ,比对str[0,sub.length-1]与sub[0,sub.length-1]是否每个元素都相等,相等时,返回 0;否则 index++
     * str index=i ,比对str[i,i+sub.length-1]与sub[0,sub.length-1]是否每个元素都相等,相等时,返回 i;否则 index++
     *
     * @return
     */
public static int find() {
    char[] str = "abcdabdc".toCharArray();
    char[] sub = "abd".toCharArray();
    for (int i = 0; i < str.length; i++) {
	if(i+j>str.length-1) return -1;// 此时str剩余子串的length<sub.length,所以不可能在查到字串了
        for (int j = 0; j < sub.length; j++) {
            if (sub[j] == str[i + j]) {
                if (j == sub.length - 1) return i;
                continue;
            }
            break;
        }
    }
    return -1;
}
```

## KMP 模板匹配算法

优化朴素模板匹配算法前 n 项匹配成功,如果子串无重复元素,则可以直接父串的 n+1 项继续匹配,从而省略 i+1 到 n 的匹配构成

kmp 算法永不退回父串指针,父串只循环一次,子串根据元素重复情况退回指针;

子串指针退回位置计算公式:

$$
next(i)=
\left \{
\begin{array}{c}
-1 ;i=0,\\
0 ;没有重复 \\
j ;前后缀最大重复串的长度\\
\end{array}
\right.
$$

```java
    public static int[] kmpNext(char[] sub) {
        if (sub == null || sub.length == 0) {
            return new int[0];
        }
        int[] next = new int[sub.length];
        next[0] = -1;
        int i = 0;//
        int j = -1;
        for (; i < next.length - 1; ) {
            if (j == -1 || sub[i] == sub[j]) {
                i++;
                j++;
                next[i] = j;
            } else {
                j = next[j];
            }
        }
        return next;
    }

    public static int kmpFind() {
        char[] str = "abcdabdc".toCharArray();
        char[] sub = "abd".toCharArray();
        int[] next = kmpNext(sub);
        int j = 0, i = 0;
        for (; i < str.length && j < sub.length; ) {
            if (j == -1 || str[i] == sub[j]) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }
        System.out.println(i + "\t" + j);
        if (j == sub.length) return i - j;
        return -1;
    }
```
