# 精确匹配

```js
/abc/ // 只能匹配abc,不能匹配"ab"，"Abc"，"abcd"等其他任何字符串。
/\&a/ // \转义特殊字符
/a\u548cc/ // 匹配字符串"a和c",中文字符和的Unicode编码是548c;默认匹配的字符为 ASCII字符
```

# 模糊匹配一个字符

```js
.     // 匹配除换行符（\n、\r）之外的任何单个字符
\w    // 匹配任意一个字母、数字、下划线
[ABC] // 相当于匹配 /A/ /B/ /C/ ,匹配[...]中的所有单个字符
[^abc] // 匹配除abc外任意一个字符
[A-Za-z0-9] // 匹配任意一个字母,数字
\S   // 非空白符，不包括换行。
\s    // 匹配有空白符,包括换行
\d  // 匹配数字
\D // 匹配非数字
```

# 非打印字符

```js
\cx   //匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\f    // 匹配一个换页符。等价于 \x0c 和 \cL。
\n    // 匹配一个换行符。等价于 \x0a 和 \cJ。
\r    //匹配一个回车符。等价于 \x0d 和 \cM。
\s    //匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。\f\n\r\t\v 】。
\t    //匹配一个制表符。等价于 \x09 和 \cI。
\v    //匹配一个垂直制表符。等价于 \x0b 和 \cK。
```

# 需要转义的字符

```js
\$  // 结尾
\(
\*
\+
\.
\[
\?
\^
\{
\|
\-
```

# 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。

正则表达式的限定符有：

```js
*     // 匹配前面的子表达式零次或多次
+     // 匹配前面的子表达式一次或多次
?     // 匹配前面的子表达式零次或一次
{n}   // n 是一个非负整数。匹配确定的 n 次
{n,}  // n 是一个非负整数。至少匹配 n 次
{n,m} // m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次
```

# 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

```js
^     // 匹配输入字符串开始的位置
$     // 匹配输入字符串结尾的位置
\b    // 匹配一个单词边界，即字与空格间的位置。
\B    //非单词边界匹配。
```

**注意**：不能将限定符与定位符连用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 `^\*`之类的表达式。

# 选择

```js
(|)  //圆括号 () 将所有选择项括起来，相邻的选择项之间用 | 分隔。
(?:a|b) // 但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 **?:** 放在第一个选项前来消除这种副作用。

// 例子
(a|b) // 能匹配a,b,不能匹配ab
```

# 先行断言和后行断言

```js
// pattern 为一个正则表达式
(?=pattern) // 零宽正向先行断言, exp1(?=exp2)：查找在 exp2 前面的 exp1。
(?!pattern) // 零宽负向先行断言, exp1(?!exp2): 查找后面不是 exp2 的 exp1
(?<=pattern) // 零宽正向后行断言,(?<=exp2)exp1：查找 exp2 后面的 exp1。
(?<!pattern) // 零宽负向后行断言,(?<!=exp2)exp1：查找前面不是 exp2 的 exp1
```

# 修饰符（标记）

标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。

标记不写在正则表达式里，标记位于表达式之外，格式如下：

```js
/pattern/flags

i // ignore - 不区分大小写
g // global - 全局匹配
m // multi line - 多行匹配
s // 特殊字符圆点 . 中包含换行符 \n
```

# 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

1. `\` 转义
2. `(), (?:), (?=), []` 圆括号和方括
3. `*, +, ?, {n}, {n,}, {n,m}` 限定
4. `^, $, \任何元字符、任何字符` 定位点和序列（即：位置和顺序）
5. `|` 或

# 命名分组

```
?<name>pattern
```

# 例子

## 1.密码校验

```js
let checkPasswd = (rule, value, callback) => {
  // console.log(rule, value, callback)
  if (value.length < 8 || value.length > 16) {
    return callback(new Error("密码长度为8-16位"))
  }
  if (/[^!#$%&()*+,-./:;<=>?@[\]^_`{|}~A-z0-9]/.test(value)) {
    return callback(new Error("字符种类限制为：!#$%&()*+,-./:;<=>?@[\\]^_`{|}~"))
  }
  const checkArr = [
    {
      regexName: "regexNum",
      value: /\d/,
    },
    {
      regexName: "regexLower",
      value: /[a-z]/,
    },
    {
      regexName: "regexUpper",
      value: /[A-Z]/,
    },
    {
      regexName: "regexSpeChar",
      value: /[!#$%&()*+,-./:;<=>?@[\]^_`{|}~]/,
    },
  ]
  let count = 0
  checkArr.forEach(item => {
    if (item.value.test(value)) {
      count++
    }
  })
  if (count < 3) {
    return callback(new Error("数字、特殊字符、大写字母、小写字母至少包含其中3种，特殊字符：!#$%&()*+,-./:;<=>?@[\\]^_`{|}~"))
  } else {
    return callback()
  }
}
```

## 2.用户名首字母为英文无汉字

```js
var str = ....
var reg = /^[a-zA-Z][^\u4e00-\u9fa5]+$/
reg.test(str)

// ^[a-zA-Z]: 限制第一个字母必须是英文或者拼音
// [^\u4e00-\u9fa5]+ 限制第二个往后不能出现中文
```
