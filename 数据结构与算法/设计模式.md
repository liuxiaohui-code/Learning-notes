# 设计模式概述

设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。

设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：**创建型模式（Creational Patterns）**、**结构型模式（Structural Patterns）**、**行为型模式（Behavioral Patterns）**。当然，我们还会讨论另一类设计模式：**J2EE 设计模式**。

**设计模式的六大原则**

1. 开闭原则（Open Close Principle）

开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

2. 里氏代换原则（Liskov Substitution Principle）

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

3. 依赖倒转原则（Dependence Inversion Principle）

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4. 接口隔离原则（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5. 迪米特法则，又称最少知道原则（Demeter Principle）

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6. 合成复用原则（Composite Reuse Principle）

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

# 创建型模式

这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

## 工厂模式（Factory Pattern）

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

**意图**：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决**：主要解决接口选择的问题。一个接口，多个实现类，通过工厂类返回接口的实现类。


**优点**： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点**：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**注意事项**：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

**实现步骤：**

1. 场景: 一个接口，多个实现类
2. 建立工厂类，工厂方法根据不同的特征值返回不同的接口实现类对象
3. 调用工厂方法（一般是静态的）

## 抽象工厂模式（Abstract Factory Pattern）

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

**意图**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决**：主要解决接口选择的问题。

**何时使用**：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。


**优点**：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点**：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**注意事项**：产品族难扩展，产品等级易扩展。

**实现步骤**

1. 使用场景：一个项目内有多个不同但相关联的接口，每个接口又有多个不同的实现类
   1. 如:
      1. 接口: Eat  实现类: IEat YouEat
      2. 接口: Say  实现类: ISay YouSay
2. 创建抽象工厂类，工厂管理几个接口就有几个工厂方法,工厂方法为通过参数获得不同的接口实现类;
   1. AbsFactory{}
   2. 工厂方法1: Eat getEat(String x) // x 为IEat YouEat 实现类的标识符
   3. 工厂方法2: Say getSay(String x) // x ISay YouSay 实现类的标识符
3. 创建工厂类，继承抽象工厂类，抽象工厂有几个方法就有几个工厂子类；每个工厂子类都返回响应的接口实现对象；
   1. EatFactoory{ Eat getEat(String x){} }
   2. SayFactoory{ Say getSay(String x){} }
4. 创建一个通过特征值获得相应抽象工厂对象的方法
   1. FactoryProducer{ public static AbsFactory getFactory(x){}} //x 为Eat Say的特征值
5. 使用相应抽象工厂对象返回响应的接口对象
   1. AbsFactory eat = FactoryProducer.getFactory("Eat")
   2. Eat ieat = eat.getEat("IEat");
   3. ieat.eat()

## 单例模式（Singleton Pattern）

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**意图**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决**：一个全局使用的类频繁地创建与销毁。

**何时使用**：当您想控制实例数目，节省系统资源的时候。

**如何解决**：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码**：构造函数是私有的。

**优点**：
1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
2、避免对资源的多重占用（比如写文件操作）。

**缺点**：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。


**注意事项**：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

单例设计模式的两种实现方式：

1. 懒汉式：随着类的加载在内存中对象为 null，当调用 getInstance 方法时才创建对象（延迟加载）
2. 饿汉式：随着类的加载直接创建对象（推荐开发中使用）

单例设计模式的实现步骤：

1. 保证一个类只有一个实例，实现方式：构造方法私有化
2. 必须要自己创建这个实例，实现方式：在本类中维护一个本类对象（私有，静态）
3. 必须向整个程序提供这个实例，实现方式：对外提供公共的访问方式（getInstance 方法，静态）

```java
//懒汉式实现如下：
class Single{
	private Single(){}
	private static Single s1 = null;
	public static synchronized  Single getInstance(){  //描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
		if(s1 == null){
			s1 = new Single();
		}
		return s1;
	}
}
//饿汉式实现如下：
class Single2{
	private Single2(){}
	private static Single2 s = new Single2();
	public static Single getInstance(){
		return s;
	}
	void print(){
		System.out.println("Hello World!");
	}
}
//采用双锁机制，安全且在多线程情况下能保持高性能。
public class Singleton {   
    private volatile static Singleton singleton;
    private Singleton (){}
    public static Singleton getSingleton() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
// 私有静态内部类的静态方法
public class Singleton {
    private static class SingletonHolder {
    	private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton (){}
    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

//枚举
public enum Singleton {   
    INSTANCE;
    public void whateverMethod() {
    }
}

```

## 建造者模式（Builder Pattern）

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

**意图**：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**主要解决**：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用**：一些基本部件不会变，而其组合经常变化的时候。

**如何解决**：将变与不变分离开。

**关键代码**：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。


**优点**： 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点**： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。


**注意事项**：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

建造者模式，又称**生成器模式**：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

三个角色：建造者、具体的建造者、监工、使用者（严格来说不算）

建造者角色：定义生成实例所需要的所有方法；
具体的建造者角色：实现生成实例所需要的所有方法，并且定义获取最终生成实例的方法；
监工角色：定义使用建造者角色中的方法来生成实例的方法；
使用者：使用建造者模式。
注意：定义中“将一个复杂的构建过程与其表示相分离”，表示并不是由建造者负责一切，而是由监工负责控制（定义）一个复杂的构建过程，由各个不同的建造者分别负责实现构建过程中所用到的所有构建步骤。不然，就无法做到“使得同样的构建过程可以创建不同的表示”这一目标。

一个产品的生产需要一次进行多个步骤:
1. 建造者抽象类: 抽象每一个步骤
2. 建造者实现类: 实现步骤;获取结果
3. 监工类: 组合建造者类, 方法 -- 控制产品生产步骤
4. 使用:
   1. 构建具体建造者
   2. 构建监工
   3. 监工组织生产
   4. 获取生产结果
```java
//建造者角色：
public abstract class Builder {
    public abstract void buildPart1();
    public abstract void buildPart2();
    public abstract void buildPart3();
}

//监工角色：
public class Director {    // 将一个复杂的构建过程与其表示相分离
    private Builder builder;    // 针对接口编程，而不是针对实现编程
    public Director(Builder builder) {
        this.builder = builder;
    }
    public void setBuilder(Builder builder) {
        this.builder = builder;
    }

    public void construct() {   // 控制（定义）一个复杂的构建过程
        builder.buildPart1();
        for (int i = 0; i < 5; i++) {   // 提示：如果想在运行过程中替换构建算法，可以考虑结合策略模式。
            builder.buildPart2();
        }
        builder.buildPart3();
    }
}
//具体的建造者角色：
/**
 * 此处实现了建造纯文本文档的具体建造者。
 * 可以考虑再实现一个建造HTML文档、XML文档，或者其它什么文档的具体建造者。
 * 这样，就可以使得同样的构建过程可以创建不同的表示
 */
public class ConcreteBuilder1 extends Builder {
  private StringBuffer buffer = new StringBuffer();//假设 buffer.toString() 就是最终生成的产品

    @Override
    public void buildPart1() {//实现构建最终实例需要的所有方法
        buffer.append("Builder1 : Part1\n");
    }

    @Override
    public void buildPart2() {
        buffer.append("Builder1 : Part2\n");
    }

    @Override
    public void buildPart3() {
        buffer.append("Builder1 : Part3\n");
    }

    public String getResult() {//定义获取最终生成实例的方法
        return buffer.toString();
    }
}
客户角色：

public class Client {
    public void testBuilderPattern() {
        ConcreteBuilder1 b1 = new ConcreteBuilder1();//建造者
        Director director = new Director(b1);//监工
        director.construct();//建造实例(监工负责监督，建造者实际建造)
        String result = b1.getResult();//获取最终生成结果
        System.out.printf("the result is :%n%s", result);
    }
}
```

## 原型模式（Prototype Pattern）

原型模式（Prototype Pattern）是用于创建**重复**的对象，同时又能保证性能。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。**当直接创建对象的代价比较大时，则采用这种模式。**例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

缓存原型,返回原型的克隆

**注意事项**：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写\深拷贝是通过实现 Serializable 读取二进制流。

实现步骤:
1. 创建一个实现了 Cloneable 接口的抽象类。Shape 
2. 创建扩展了上面抽象类的实体类。Rectangle Square Circle 
3. 创建一个类，从数据库获取实体类ShapeCache ，并把它们存储在一个 Hashtable 中。
4. PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。

# 结构型模式

这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

## 适配器模式（Adapter Pattern）
适配器模式（Adapter Pattern）是作为两个**不兼容**的接口之间的桥梁。

**优点**： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

**缺点**： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

步骤:
1. 前提: 两个不兼容的接口
   1. MediaPlayer 媒体播放接口 
      1. void play(String audioType, String fileName);
   2. AdvancedMediaPlayer 更先进的媒体播放接口 
      1. void playVlc(String fileName);
      2. void playMp4(String fileName);
   3. AdvancedMediaPlayer实现类:
      1. VlcPlayer 
      2. Mp4Player 
   4. MediaPlayer实现类
      1. AudioPlayer 需要使用适配器来兼容
2. MediaPlayer适配器: class MediaAdapter implements MediaPlayer
   1. 组合 AdvancedMediaPlayer
   2. 有参构造函数(String audioType)
   3. 实现play: 通过播放类型调用AdvancedMediaPlayer的不同接口
3. 改造AudioPlayer
   1. 组合 MediaAdapter
   2. 改造play: 通过播放类型创建 MediaAdapter 对象,并调用 MediaAdapter 的 play方法
4. 使用
   1. MediaPlayer player = new AudioPlayer();
   2. player.play(....)


## 桥接模式（Bridge Pattern）
桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

1. 前提: 一个接口,多个实现类;
2. 桥接: 抽象类
   1. 组合接口
   2. 抽象接口方法
3. 实现抽象类
4. 使用: 使用实现类初始化抽象类,调用方法

优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。

缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。

## 过滤器模式（Filter、Criteria Pattern）
**过滤器模式**（Filter Pattern）或**标准模式**（Criteria Pattern）是一种设计模式，这种模式**允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来**。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

1. 问题: 数据集(对象列表)通过一系列标准过滤,得到结果集
2. 准备对象
3. 设置标准接口
4. 实现接口: 单个标准,组合标准
5. 调用接口获取结果
``` java
public interface Criteria {
   public List<Integer> computeCriteria(List<Integer> list);
}
//单个标准 >
class DaYuCriteria implements Criteria{
    Integer min;
    DaYuCriteria(Integer min){
        this.min = min;
    }
    public List<Integer> computeCriteria(List<Integer> list){
        List<Integer> res = new ArrayList<>();
        for(Integer i : list){
            if(i>min){
                res.add(i)
            }
        }
        return res;
    }
}
class XiaoYuCriteria implements Criteria{
    Integer max;
    XiaoYuCriteria(Integer max){
        this.max = max;
    }
    public List<Integer> computeCriteria(List<Integer> list){
        List<Integer> res = new ArrayList<>();
        for(Integer i : list){
            if(i<max){
                res.add(i)
            }
        }
        return res;
    }
}
//组合标准
class ZuHeCriteria implements Criteria{
    Criteria max;
    Criteria min;
    ZuHeCriteria(Criteria max,Criteria min){
        this.max = max;
        this.min = min;
    }
    public List<Integer> computeCriteria(List<Integer> list){
        list = max.computeCriteria(list);
        list = min.computeCriteria(list);
        return list;
    }
}
//使用

```
## 组合模式（Composite Pattern）
组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

优点： 1、高层模块调用简单。 2、节点自由增加。

缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。

注意事项：定义时为具体类。

1. 一个类,其中一个属性为自身类对象列表
``` java
class 员工{
    String name;
    List<员工> list;
    员工(String name){this.name = name;this.list = new ArrayList<>()}
    add(){}
    remove(){}

    psvm{
        ceo = new 员工();
        经理1 = new 员工();
        经理2 = new 员工();
        职员 = new 员工();
        ceo.add(经理1);
        ceo.add(经理2);
        经理2.add(职员)
        // 对象形成一个树形结构
    }
}
```
## 装饰器模式（Decorator Pattern）
装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
1. 一个接口,如 Draw;两个实现: 圆 方
2. 一个抽象装饰类,实现接口方法;组合接口,通过组合属性实现方法;
3. 装饰实体类: 重写接口方法: 比如在接口方法的基础上,添加颜色,更改位置,修改背景...都可以通过增加装饰实体类的方式为现有对象增加属性


## 外观模式（Facade Pattern）
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。
关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。
缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。
使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。
注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。

1. 场景: 一个接口三种实现
2. 设计外观类
   1. 组合三个接口类型的属性的类
   2. 通过接口对象将每个实现类的实现方法重定义为外观类方法
3. 使用外观类即可获取接口的所有实现方法


## 享元模式（Flyweight Pattern）
享元模式（Flyweight Pattern）主要用于**减少创建对象的数量**，以**减少内存占用和提高性能**。这种类型的设计模式属于结构型模式，它提供了**减少对象数量从而改善应用所需的对象结构**的方式。

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。

1. 一个接口,一个实现类
2. 享元 --- 是一个生产接口对象的工厂类
   1. 属性: 缓存接口对象的Map
   2. 获取接口对象的方法:
      1. map 中有了,直接返回
      2. map 中没有,创建\存入,返回刚创建的

## 代理模式（Proxy Pattern）
在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。创建具有现有对象的对象，以便向外界提供功能接口。

意图：为其他对象提供一种代理以控制对这个对象的访问。

主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

优点： 1、职责清晰。 2、高扩展性。 3、智能化。
缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

1. 一个接口,一个实现类
2. 代理: 代理实现类
   1. 实现接口
   2. 组合要代理的实现类
   3. 代理属性
   4. 用组合的实现类对象实现接口方法 // 再此可以校验代理属性,来控制实现


# 行为型模式

这些设计模式特别关注对象之间的通信。

## 责任链模式（Chain of Responsibility Pattern）

责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。

意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。

缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。

1. 责任链抽象类
   1. 静态属性: 对象类别
   2. 属性: 类别
   3. 属性: 责任链的下一个元素
   4. 方法: setNext() 设置责任链的下一个元素
   5. 方法: 责任链传递: 根据参数判断将数据交由责任链上的哪一个对象调用
   6. 抽象方法: 责任链传递的数据的执行方法
2. 责任链实现类: 数量与类别种类一致
3. 使用:
   1. 初始化所有实现类对象,构成一条责任链
   2. 调用责任链的参数传递方法处理数据
4. 实例: 日志系统 INFO-DEBUG-ERROR 构成一条责任链

## 命令模式（Command Pattern）
命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

1. 一个类A,有很多方法
2. 一个命令执行的接口B,一个接口方法: 执行execute()
3. 把A中的行为方法单个抽出来,在execute()中调用,组成一个个B的实现类
4. 创建命令调用类,
   1. 属性: 存储命令的队列
   2. 方法add: 添加命令到队列
   3. 方法execute: 循环执行队列的所有命令


## 解释器模式（Interpreter Pattern）
解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
1. 创建一个解释器接口: 解释(data)
2. 多种:实现解释器   // data 在某种解释器中代表什么意思 
3. 解释器之间可以组合嵌套
4. 调用

意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

主要解决：对于一些固定文法构建一个解释句子的解释器。

何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

如何解决：构建语法树，定义终结符与非终结符。

关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。

应用实例：编译器、运算表达式计算。

优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。

缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。
## 迭代器模式（Iterator Pattern）
迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式**用于顺序访问集合对象的元素，不需要知道集合对象的底层表示**。

如何解决：**把在元素之间游走的责任交给迭代器，而不是聚合对象**。

关键代码：定义接口：`hasNext`, `next`。

优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

## 中介者模式（Mediator Pattern）
中介者模式（Mediator Pattern）是用来**降低多个对象和类之间的通信复杂性**。这种模式**提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护**。中介者模式属于行为型模式。

应用场景：多个类相互耦合，形成了网状结构,将上述**网状结构分离为星型结构**。

关键代码：**对象之间的通信封装到一个类中单独处理**。

优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。

缺点：中介者会庞大，变得复杂难以维护。

使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

注意事项：不应当在职责混乱的时候使用。
## 备忘录模式（Memento Pattern）
备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。

意图：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态**。

如何解决：通过一个备忘录类专门存储对象状态。

关键代码：**客户不与备忘录类耦合，与备忘录管理类耦合**。

应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理。

优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。

缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。

注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。

1. 数据类
2. 备忘录类(标识数据类对象的唯一状态)
3. 备忘录管理类(备份,恢复)
## 观察者模式（Observer Pattern）
当对象间存在**一对多**关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

如何解决：使用面向对象技术，可以将这种依赖关系弱化。

关键代码：在抽象类里有一个 ArrayList 存放观察者们。

应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。

优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

1. 被观察对象类:
   1. 存储所有观察者
   2. 执行操作时,通知所有观察者更新
   3. 管理观察者
2. 观察模式接口:
   1. 被观察对象
   2. 更新()
## 状态模式（State Pattern）
在状态模式（State Pattern）中，**类的行为是基于它的状态改变的**。这种类型的设计模式属于行为型模式。

通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。


优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。

注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。
1. 状态接口 doAction(Context context)
2. 实现类: 根据 context 的状态,实现不同的操作
3. 对象类Context
   1. 状态标识
## 空对象模式（Null Object Pattern）
在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。

在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。

1. 结合工厂模式使用
2. 一个类,一个实现
3. 增加一个空对象实现
4. 工厂生产对象,当对象标识不存在时,返回空对象实现实例
5. 调用工厂实例获得类对象
## 策略模式（Strategy Pattern）
在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

1. 策略接口
2. 策略多种实现,多种策略
3. 策略使用类:
   1. 组合策略接口
   2. 设置策略
   3. 行为方法: 根据策略不同,实行函数时调用相应的策略方法
## 模板模式（Template Pattern）
在模板模式（Template Pattern）中，**一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行**。这种类型的设计模式属于行为型模式。

优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。

缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。

注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。

1. 模板类
   1. 抽象方法
   2. 模板实例方法: 固定执行抽象方法的位置和顺序 

``` java
abstract class GameTemplate{
    abstract void start();
    abstract void running();
    abstract void end();

    void play(){
        start();
        running();
        end();
    }
}
```
## 访问者模式（Visitor Pattern）
在访问者模式（Visitor Pattern）中，我们使用了**一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变**。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。
# J2EE 模式

这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

## MVC 模式（MVC Pattern）

## 业务代表模式（Business Delegate Pattern）

## 组合实体模式（Composite Entity Pattern）

## 数据访问对象模式（Data Access Object Pattern）

## 前端控制器模式（Front Controller Pattern）

## 拦截过滤器模式（Intercepting Filter Pattern）

## 服务定位器模式（Service Locator Pattern）

## 传输对象模式（Transfer Object Pattern）
