# 视图

视图并不同于数据表，它们的区别在于以下几点：

- 视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。
- 存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。
- 视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。
- 视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。
- 视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。
- 从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。
- 视图的建立和删除只影响视图本身，不影响对应的基本表。

优点：

1. 定制用户数据，聚焦特定的数据
2. 简化数据操作
3. 提高数据的安全性
4. 共享所需数据
5. 更改数据格式
6. 重用 SQL 语句

视图可以嵌套,但不能有索引,也不能有关联的触发器或默认值
性能问题: 视图因为只有结构而没有数据,因此,每次使用视图时,都会进行一次查询操作,如果视图比较复杂,性能下降的比较厉害

## 1. 创建

```sql
# 创建视图
CREATE VIEW <视图名> AS <SELECT语句> ;
/*
对于创建视图中的 SELECT 语句的指定存在以下限制：
用户除了拥有 CREATE VIEW 权限外，还具有操作中涉及的基础表和其他视图的相关权限。
SELECT 语句不能引用系统或用户变量。
SELECT 语句不能包含 FROM 子句中的子查询。
SELECT 语句不能引用预处理语句参数。
*/
```

> ​ 视图定义中引用的表或视图必须存在。但是，创建完视图后，可以删除定义引用的表或视图。可使用 CHECK TABLE 语句检查视图定义是否存在这类问题。
>
> ​ 视图定义中允许使用 ORDER BY 语句，但是若从特定视图进行选择，而该视图使用了自己的 ORDER BY 语句，则视图定义中的 ORDER BY 将被忽略。
>
> ​ 视图定义中不能引用 TEMPORARY 表（临时表），不能创建 TEMPORARY 视图。
>
> ​ WITH CHECK OPTION 的意思是，修改视图时，检查插入的数据是否符合 WHERE 设置的条件。

## 2. 查询

```sql
DESCRIBE 视图名;  -- 可简写为 desc;查询视图字段讯息
SHOW CREATE VIEW 视图名 \G; --  \G 格式化输出;查看视图的详细信息
SELECT * FROM information_schema.views; -- 查看所有视图;所有视图的定义都是存储在 information_schema 数据库下的 views 表中，也可以在这个表中查看所有视图的详细信息
select * from 视图名; -- 查看视图数据类似于表
```

## 3. 修改

```sql
ALTER VIEW <视图名> AS <SELECT语句>; -- 修改视图
```

某些视图是可更新的。也就是说，可以使用 UPDATE、DELETE 或 INSERT 等语句更新基本表的内容。对于可更新的视图，视图中的行和基本表的行之间必须具有一对一的关系。

还有一些特定的其他结构，这些结构会使得视图不可更新。更具体地讲，如果视图包含以下结构中的任何一种，它就是不可更新的：

- 聚合函数 SUM()、MIN()、MAX()、COUNT() 等。
- DISTINCT 关键字。
- GROUP BY 子句。
- HAVING 子句。
- UNION 或 UNION ALL 运算符。
- 位于选择列表中的子查询。
- FROM 子句中的不可更新视图或包含多个表。
- WHERE 子句中的子查询，引用 FROM 子句中的表。
- ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。

## 4. 删除

```sql
DROP VIEW <视图名1> [ , <视图名2> …];
```
