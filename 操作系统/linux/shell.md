# 基本

```sh
!/bin/bash
# 1.sh
# 脚本
echo "Hello World !"

# 单行注释
# 多行注释
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
# EOF 也可以使用其他符号:
:<<'
注释内容...
注释内容...
注释内容...
'

:<<!
注释内容...
注释内容...
注释内容...
!
```

运行

```sh
1. 作为可执行程序
chmod +x ./1.sh
./1.sh

2.作为解释器参数，这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。
/bin/sh test.sh
/bin/php test.php
```

# 变量

## 定义

```sh
var_name=var_value

# 注意：
	1. 变量名和等号之间不能有空格
	2. 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
	3. 中间不能有空格，可以使用下划线 _。
	4. 不能使用标点符号。
	5. 不能使用bash里的关键字（可用help命令查看保留关键字）。

# 已定义的变量，可以被重新定义，即重新赋值
```

## 调用

```sh
${var_name}

# 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界
```

## 限定

```sh
readonly var_name  #var_name 只读，
```

## 类型

```sh
# 局部变量
	局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
# 环境变量
	所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
# shell变量
	shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行
```

# 字符串

## 定义

​ 字符串可以用单引号，也可以用双引号，也可以不用引号。

```sh
# 单引号字符串的限制：

	单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
	单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

# 双引号的优点：

	双引号里可以有变量
	双引号里可以出现转义字符
```

## 拼接

​ 两个字符串连接即可，中间不需要任何符号

```sh
your_name="runoob"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
# hello, runoob ! hello, runoob !

# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
# hello, runoob ! hello, ${your_name} !
```

## 长度

```sh
string="abcd"
echo ${#string} #输出 4
```

## 提取子串

```sh
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo [1,4]

#注意：第一个字符的索引值为 0。
```

## 查找子串

```sh
# 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：
string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4

```

## echo

```sh
echo {"string"}
echo -e {"string\n"} #开启转义，如换行\n,不换行\c
echo {"string"} > {file} # 显示结果定向至文件
ehco {`cmd`} # 显示命令执行结果
```

```bash
功能说明：显示文字。
语 法：echo [-ne][字符串]或 echo [--help][--version]
补充说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开，并在最后加上换行号。
参 数：
-n 不要在最后自动换行
-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：
	\a 发出警告声；
	\b 删除前一个字符；
	\c 最后不加上换行符号；
	\f 换行但光标仍旧停留在原来的位置；
	\n 换行且光标移至行首；
	\r 光标移至行首，但不换行；
	\t 插入tab；
	\v 与\f相同；
	\\ 插入\字符；
	\nnn 插入nnn（八进制）所代表的ASCII字符；
--help 显示帮助
--version 显示版本信息

每一个shell支持的echo指令可能都不太相同。
-n 不输出最后的\n
-e解释转义字符
-E不解释转义字符
```

## `printf`

```sh
printf  format-string  [arguments...]

format-string:
 	%s 输出一个字符串， #%-10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。
 	%d 整型输出，
 	%c 输出一个字符，
 	%f 输出实数，以小数形式输出。 #%-4.2f 指格式化为小数，其中 .2 指保留2位小数。
 	%b: 字符串--相对应的参数被视为含有要被处理的转义序列之字符串

 	单引号与双引号效果一样
 	格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
 	如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
```

### printf 的转义序列

| 序列  | 说明                                                                                                                                                                          |
| :---- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \a    | 警告字符，通常为 ASCII 的 BEL 字符                                                                                                                                            |
| \b    | 后退                                                                                                                                                                          |
| \c    | 抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 |
| \f    | 换页（formfeed）                                                                                                                                                              |
| \n    | 换行                                                                                                                                                                          |
| \r    | 回车（Carriage return）                                                                                                                                                       |
| \t    | 水平制表符                                                                                                                                                                    |
| \v    | 垂直制表符                                                                                                                                                                    |
| \\    | 一个字面上的反斜杠字符                                                                                                                                                        |
| \ddd  | 表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效                                                                                                                          |
| \0ddd | 表示 1 到 3 位的八进制值字符                                                                                                                                                  |

# 数组

## 定义

```sh
# bash支持一维数组（不支持多维数组），并且没有限定数组的大小。
# 用括号来表示数组，数组元素用"空格"符号分割开
array_name=(value0 value1 value2 value3)

array_name=(
value0
value1
value2
value3
)

array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
# 可以不使用连续的下标，而且下标的范围没有限制。
```

## 读取数组

```sh
${数组名[下标]}
```

## 获取数组的长度

获取数组长度的方法与获取字符串长度的方法相同，例如：

```sh
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}

# 取得数组单个元素的长度
lengthn=${#array_name[n]}
```

# 参数传递

```sh
#!/bin/bash
echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";

# 运行
./shell_name.sh arg1 arg2 ...
```

## 默认参数

```sh
${1:-'1'}

```

# 运算符

原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

两点注意：

- 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
- 完整的表达式要被 **` `** 包含，注意这个字符不是常用的单引号，在 Esc 键下边。

## expr

```sh
result=$[a + b]
等同于：
result=`expr $a + $b `
```

## $

| 参数处理 | 说明                                                           |
| :------- | :------------------------------------------------------------- |
| `$#`     | 传递到脚本的参数个数                                           |
| `$*`     | 以一个单字符串显示所有向脚本传递的参数。                       |
| `$$`     | 脚本运行的当前进程 ID 号                                       |
| `$!`     | 后台运行的最后一个进程的 ID 号                                 |
| `$@ `    | 与``$*`相同，但是使用时加引号，并在引号中返回每个参数。        |
| `$- `    | 显示 Shell 使用的当前选项                                      |
| `$?`     | 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。 |

（1）`${a}` 变量 a 的值, 在不引起歧义的情况下可以省略大括号。
（2）`$(cmd)` 命令替换，和`cmd`效果相同，结果为 shell 命令 cmd 的输，过某些 Shell 版本不支持$()形式的命令替换, 如tcsh。
（3）`$((expression))` 和`exprexpression`效果相同, 计算数学表达式 exp 的数值, 其中 exp 只要符合 C 语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。

## `()`

```shell
# 1. 命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。
$(cd ..,echo 'xx')
# 2. 命令替换。等同于`cmd`，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。
result=$(cmd)
# 3. 用于初始化数组。如：
array=(a b c d)
```

## `(())`

```shell
# 1. 整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。
echo $((1+1)) #2
# 2. 只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。
echo $((16#5f)) # 结果为95 (16进位转十进制)
# 3. 单纯用 (( )) 也可重定义变量值
a=5; ((a++)) # 可将 $a 重定义为6
# 4. 常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i<5;i++)), 如果不使用双括号, 则为for i in `seq 0 4`或者for i in {0..4}。再如可以直接使用if (($i<5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。

```

## `[]`

```shell
# 1. bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的
if [ 1 -eq 1 ];then fi
# 2. Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。
[ == ]
[ != ]
# 3.字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。
# 4.在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。
```

## `[[]]`

```shell
# 1. [[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。
# 2. 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。
[[ hello == hell? ]] # true
# 3. 使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。
比如可以直接使用 if [[ $a != 1 && $a != 2 ]],
如果不适用双括号, 则为 if [ $a -ne 1] && [ $a != 2 ]或者 if [ $a -ne 1 -a $a != 2 ]。

# 4. bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。。
```

## `{}`

```Shell
(1) 大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt
(2) 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。

${var:-string} 默认值
${var:+string} var有值是替换
${var:=string} 默认值
${var:?string} 若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。
```

## awk

awk 是一种编程语言，用于在 linux/unix 下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是 linux/unix 下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk 有很多内建的功能，比如数组、函数等，这是它和 C 语言的相同之处，灵活性是 awk 最大的优势。

## test

```sh
test $[] 运算符 $[]  # false|true

代码中的 [] 执行基本的算数运算
```

## 算术运算符

下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                          | 举例                         |
| :----- | :-------------------------------------------- | :--------------------------- |
| +      | 加法                                          | `expr $a + $b` 结果为 30。   |
| -      | 减法                                          | `expr $a - $b` 结果为 -10。  |
| \*     | 乘法                                          | `expr $a \* $b` 结果为 200。 |
| /      | 除法                                          | `expr $b / $a` 结果为 2。    |
| %      | 取余                                          | `expr $b % $a` 结果为 0。    |
| =      | 赋值                                          | a=$b 把变量 b 的值赋给 a。   |
| ==     | 相等。用于比较两个数字，相同则返回 true。     | `[ $a == $b ] `返回 false。  |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。 | `[ $a != $b ] `返回 true。   |

**注意：**条件表达式要放在方括号之间，并且要有空格，例如: `[$a==$b] `是错误的，必须写成`[ $a == $b ]`。

## 关系运算符

关系运算符只支持**数字**，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                          |
| :----- | :---------------------------------------------------- | :---------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | `[ $a -eq $b ]` 返回 false。  |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | `[ $a -ne $b ] `返回 true。   |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | `[ $a -gt $b ]` 返回 false。  |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | `[ $a -lt $b ]` 返回 true。   |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | ` [ $a -ge $b ]` 返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[ $a -le $b ]` 返回 true。   |

## 布尔运算符

下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                | 举例                                       |
| :----- | :-------------------------------------------------- | :----------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                    |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | `[ $a -lt 20 -o $b -gt 100 ] `返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | `[ $a -lt 20 -a $b -gt 100 ]` 返回 false。 |

## 逻辑运算符

以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:
`&&` 逻辑的 AND | `[[ $a -lt 100 && $b -gt 100 ]] `返回 false
`||` 逻辑的 OR | `[[ $a -lt 100 || $b -gt 100 ]]` 返回 true

## 字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                       |
| :----- | :------------------------------------------- | :------------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | `[ $a = $b ] `返回 false。 |
| !=     | 检测两个字符串是否不相等，不相等返回 true。  | `[ $a != $b ]` 返回 true。 |
| -z     | 检测字符串长度是否为 0，为 0 返回 true。     | `[ -z $a ]` 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | `[ -n "$a" ] `返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | `[ $a ] `返回 true。       |

## 文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

属性检测描述如下：

| 操作符  | 说明                                                                        | 举例                         |
| :------ | :-------------------------------------------------------------------------- | :--------------------------- |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。                             | ` [ -b $file ]` 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。                           | `[ -c $file ]` 返回 false。  |
| -d file | 检测文件是否是目录，如果是，则返回 true。                                   | `[ -d $file ] `返回 false。  |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | `[ -f $file ]`返回 true。    |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。                           | `[ -g $file ] `返回 false。  |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。                 | `[ -k $file ]` 返回 false。  |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                               | `[ -p $file ]` 返回 false。  |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。                           | `[ -u $file ] `返回 false。  |
| -r file | 检测文件是否可读，如果是，则返回 true。                                     | `[ -r $file ]` 返回 true。   |
| -w file | 检测文件是否可写，如果是，则返回 true。                                     | `[ -w $file ]` 返回 true。   |
| -x file | 检测文件是否可执行，如果是，则返回 true。                                   | `[ -x $file ] `返回 true。   |
| -s file | 检测文件是否为空（文件大小是否大于 0），不为空返回 true。                   | `[ -s $file ]` 返回 true。   |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。                         | `[ -e $file ] `返回 true。   |

其他检查符：

- **-S**: 判断某文件是否 socket。
- **-L**: 检测文件是否存在并且是一个符号链接。

# 流程控制

## if

```sh
if condition; then

elif condition; then

else
	#如果 else 分支没有语句执行，就不要写这个 else
fi
```

## for

```sh
for var in item1 item2 ... itemN
do
	command1...
done

for((assignment;condition:next));do
    command_1;
    command_2;
    commond_..;
done; # bash支持这种写法
```

## while

```sh
while condition
do
	command
done

$[ condition ] == false ;break
```

## until

```sh
until condition
do
	command
done

$[ condition ] == true ;break
```

## case

```sh
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;  #用两个分号 ;; 表示 break
模式2)
    command1
    command2
    ...
    commandN
    ;;
 *) #如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。
 	command
 	;;
esac
```

## 循环控制 break/continue

# 函数

```sh
[ function ] funname [()]
{
    action;
    [return int;]
}

function hello(){
	params1=$1 # 函数的参数
	echo $params1
	return 1 # 只能返回数字
}
# 调用函数
hello 2
# 获取返回值
echo $? # 1
# 获取函数内部打印的echo
echo $(hello 2) # 2

1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)
```

# 输入/输出重定向

| 命令            | 说明                                                                  |
| :-------------- | :-------------------------------------------------------------------- |
| command > file  | 将输出重定向到 file。                                                 |
| command < file  | 将输入重定向到 file。本来需要从键盘获取输入的命令会转移到文件读取内容 |
| command >> file | 将输出以追加的方式重定向到 file。                                     |
| n > file        | 将文件描述符为 n 的文件重定向到 file。                                |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。                    |
| n >& m          | 将输出文件 m 和 n 合并。                                              |
| n <& m          | 将输入文件 m 和 n 合并。                                              |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。                    |

_需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。_

## 重定向深入讲解

一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：

- 标准输入文件(stdin)：stdin 的文件描述符为 0，Unix 程序默认从 stdin 读取数据。
- 标准输出文件(stdout)：stdout 的文件描述符为 1，Unix 程序默认向 stdout 输出数据。
- 标准错误文件(stderr)：stderr 的文件描述符为 2，Unix 程序会向 stderr 流中写入错误信息。

默认情况下，command > file 将 stdout 重定向到 file，command < file 将 stdin 重定向到 file。

如果希望 stderr 重定向到 file，可以这样写：

```
$ command 2>file
```

如果希望 stderr 追加到 file 文件末尾，可以这样写：

```
$ command 2>>file
```

**2** 表示标准错误文件(stderr)。

如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：

```
$ command > file 2>&1

或者

$ command >> file 2>&1
```

如果希望对 stdin 和 stdout 都重定向，可以这样写：

```
$ command < file1 >file2
```

command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。

## Here Document

Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。

它的基本的形式如下：

```
command << delimiter
    document
delimiter
```

它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。

> 注意：
>
> - 结尾的 delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
> - 开始的 delimiter 前后的空格会被忽略掉。

## /dev/null 文件

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

```
$ command > /dev/null
```

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

```
$ command > /dev/null 2>&1
```

> **注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。
>
> 这里的 **2** 和 **>** 之间不可以有空格，**2>** 是一体的时候才表示错误输出。

# 文件包含

和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

Shell 文件包含的语法格式如下：

```sh
# 注意点号(.)和文件名中间有一空格
. filename
#或
source filename
# 可以加参数
source filename 1 2 3
# 子文件内部使用$1 $2 $3 接收
# 子文件内部使用相对路径是相对于调用方的
```

# 控制台读取

```shell
read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量

read -p "输入提示:" -t 输入等待时间(秒) 变量名
```

# set

​ set 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值。当指定某个单一的选项时将设置 shell 的常用特性，如果在选项后使用 -o 参数将打开特殊特性，若是 +o 将关闭相应的特殊特性。而不带任何参数的 set 指令将显示当前 shell 中的全部变量，且总是返回 true，除非遇到非法的选项。

| 参数      | 说明                                                                      |
| :-------- | :------------------------------------------------------------------------ |
| -a        | 标示已修改的变量，以供输出至环境变量                                      |
| -b        | 使被中止的后台程序立刻回报执行状态                                        |
| -d        | Shell 预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d 参数可取消 |
| -e        | 若指令传回值不等于 0，则立即退出 shell                                    |
| -f        | 取消使用通配符                                                            |
| -h        | 自动记录函数的所在位置                                                    |
| -k        | 指令所给的参数都会被视为此指令的环境变量                                  |
| -l        | 记录 for 循环的变量名称                                                   |
| -m        | 使用监视模式                                                              |
| -n        | 测试模式，只读取指令，而不实际执行                                        |
| -p        | 启动优先顺序模式                                                          |
| -P        | 启动-P 参数后，执行指令时，会以实际的文件或目录来取代符号连接             |
| -t        | 执行完随后的指令，即退出 shell                                            |
| -u        | 当执行时使用到未定义过的变量，则显示错误信息                              |
| -v        | 显示 shell 所读取的输入值                                                 |
| -H shell  | 可利用”!”加<指令编号>的方式来执行 history 中记录的指令                    |
| -x        | 执行指令后，会先显示该指令及所下的参数                                    |
| +<参数>   | 取消某个 set 曾启动的参数。与-<参数>相反                                  |
| -o option | 特殊属性有很多，大部分与上面的可选参数功能相同，这里就不列了              |
