# MySQL

使用第三方开源的mysql库: 

github.com/go-sql-driver/mysql （mysql驱动） 

github.com/jmoiron/sqlx （基于mysql驱动的封装）

命令行输入 ：

```go
import(
	_ "github.com/go-sql-driver/mysql"
    "go get github.com/jmoiron/sqlx"
)
```

## 1. 链接mysql

```go
database, err := sqlx.Open("数据库类型", "用户名:密码@tcp(地址:端口)/数据库名")
defer database.Close()
```

## 2. 简单运用

```go
//插入 
r, err := Db.Exec("insert into person(username, sex, email)values(?, ?, ?)", "stu001", "man", "stu01@qq.com")
//查询
var person []Person
    err := Db.Select(&person, "select user_id, username, sex, email from person where user_id=?", 1)
//更新
 res, err := Db.Exec("update person set username=? where user_id=?", "stu0003", 1)
//删除
 res, err := Db.Exec("delete from person where user_id=?", 1)
//事务
    1)  Db.Begin()        开始事务
    2)  Db.Commit()       提交事务
    3)  Db.Rollback()     回滚事务
```



# Redis

## 1. Redis 简介

Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。

Redis 与其他 key - value 缓存产品有以下三个特点：

```
    Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
    Redis不仅仅支持简单的key-value类型的数据，同时还提供string、list（链表）、set（集合）、hash表等数据结构的存储。
    Redis支持数据的备份，即master-slave模式的数据备份。
```

## 2. Redis 优势

性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s ，单机能够达到15w qps，通常适合做缓存。

丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。

原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。

丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。

Redis与其他key-value存储有什么不同？

Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。

Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。

## 3. redis使用

使用第三方开源的redis库: github.com/garyburd/redigo/redis

命令行输入 ：

```go
import "github.com/garyburd/redigo/redis"
```

## 4. redis连接

```go
//c, err := redis.Dial("tcp", "localhost:6379")
c, err := redis.Dial("tcp", "localhost:6379",redis.DialPassword("123456"))
defer c.Close()
```

## 5. 简单运用

```go
n, err := conn.Do("APPEND", "key", "value")

_, err = c.Do("Set", "abc", 100)
r, err := redis.Int(c.Do("Get", "abc"))

//批量
 _, err = c.Do("MSet", "abc", 100, "efg", 300)
r, err := redis.Ints(c.Do("MGet", "abc", "efg"))
//设置过期时间 10秒
_, err = c.Do("expire", "abc", 10)
//列表  类似栈 先进后出
_, err = c.Do("lpush", "book_list", "abc", "ceg", 300)
r, err := redis.String(c.Do("lpop", "book_list")) //300
```

## 6. Redis 连接池

```go
var pool *redis.Pool  //创建redis连接池
func init(){
    pool = &redis.Pool{     //实例化一个连接池
        MaxIdle:16,    //最初的连接数量
        // MaxActive:1000000,    //最大连接数量
        MaxActive:0,    //连接池最大连接数量,不确定可以用0（0表示自动定义），按需分配
        IdleTimeout:300,    //连接关闭时间 300秒 （300秒不使用自动关闭）    
        Dial: func() (redis.Conn ,error){     //要连接的redis数据库
            return redis.Dial("tcp","localhost:6379")
        },
    }
}

func main(){
    c := pool.Get() //从连接池，取一个链接
    defer c.Close() //函数运行结束 ，把连接放回连接池

        _,err := c.Do("Set","abc",200)
        if err != nil {
            fmt.Println(err)
            return
        }

        r,err := redis.Int(c.Do("Get","abc"))
        if err != nil {
            fmt.Println("get abc faild :",err)
            return
        }
        fmt.Println(r)
        pool.Close() //关闭连接池
}
```

