# yaml

## import

```go
import yaml "gopkg.in/yaml.v2"
```

# viper

## 包

```go
import "github.com/spf13/viper"
```

## 文件类型

```go
// type: yaml json hcl properties toml env json ini
viper.SetConfigType("[type]")
```

## 初始化

```go
	viper.SetConfigName("config") // 不含后缀的文件名
	viper.SetConfigType("yaml")   // 文件后缀名
	viper.AddConfigPath(".")      // 文件所在路径
	if err := viper.ReadInConfig(); err != nil {
		panic(err)
	}

/*
有几点需要注意：

设置文件名时不要带后缀；
搜索路径可以设置多个，viper 会根据设置顺序依次查找；
viper 获取值时使用section.key的形式，即传入嵌套的键名；
默认值可以调用viper.SetDefault设置。
*/
```

viper 的使用非常简单，它需要很少的设置。设置文件名（`SetConfigName`）、配置类型（`SetConfigType`）和搜索路径（`AddConfigPath`），然后调用`ReadInConfig`。 viper 会自动根据类型来读取配置。使用时调用`viper.Get`方法获取键值。

## 写入文件
``` go
viper.SetDefault("name", "dogger") //设置默认值


viper.WriteConfig() // 覆盖写入
viper.WriteConfigAs("new-server.yaml") // 直接写入，有内容就覆盖，没有文件就新建
viper.SafeWriteConfig() // 保存到不存在文件;存在会报错
viper.SafeWriteConfigAs("new-server.yaml") // 保存到不存在的新文件;存在会报错
```
## 读取
``` go
AllKeys()
Get...()
```
## key/value 存储
在 Viper 中启用远程支持，需要在代码中匿名导入viper/remote这个包。
import _ "github.com/spf13/viper/remote"

## 序列化

前提：​**为结构体属性打上标签**

```go
type StructInfo struct{
    xx typeName `yaml:"yaml文件内的key值"`
    ...
}

// 将整个config.yaml所有内容反序列化到rawval
func Unmarshal(rawVal interface{}) error

// 将key对应的值反序列化为结构体 rawVal
func UnmarshalKey(key string, rawVal interface{}) error
```


## 优先级

Viper 会按照下面的优先级。每个项目的优先级都高于它下面的项目:

1. 显示调用Set设置值
2. 命令行参数（flag）
3. 环境变量
4. 配置文件
5. key/value 存储
6. 默认值

> 重要： 目前 Viper 配置的键（Key）是大小写不敏感的。目前正在讨论是否将这一选项设为可选。

## 监控并实时监控配置文件改动
``` go
viper.WatchConfig()
viper.OnConfigChange(func(e fsnotify.Event) {
  // 配置文件发生变更之后会调用的回调函数
	fmt.Println("Config file changed:", e.Name)
})

```

# protobuf
# golang 使用

## 下载源码

https://github.com/protocolbuffers/protobuf/releases

把 bin 添加到 path

### protobuf 插件

go 语言相关的有两个插件 gogoprotobuf 和 goprotobuf(官方出品)

```shell
# 常用
$ go get github.com/gogo/protobuf/protoc-gen-gofast
# 官方
$ go get github.com/golang/protobuf/protoc-gen-go
```

## 编译

开始编写.proto 文件，编写完运行此命令

```shell
# 常用
$ protoc --gofast_out=. a.proto
# 官方
$ protoc --go_out=. hello.proto
$ protoc --go_out=plugins=grpc:. hello.proto
```

## bug

### 1. protoc --go_out=. hello.proto

```
protoc-gen-go: unable to determine Go import path for "myproto.proto"

Please specify either:
        • a "go_package" option in the .proto source file, or
        • a "M" argument on the command line.

See https://developers.google.com/protocol-buffers/docs/reference/go-generated#package for more information.

--go_out: protoc-gen-go: Plugin failed with status code 1.
```

solution：

​ 在源文件中添加：

```protobuf
option go_package ="dir_path/pkg_name"; // 将会在 dir_path/pkg_name文件夹下生成包为`pkg_name`的xx.pb.go
```
