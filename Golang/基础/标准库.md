# fmt 字符串格式化输入输出

fmt 包实现了类似 C 语言 printf 和 scanf 的格式化 I/O。主要分为向外输出内容和获取输入内容两大部分。

1. 输出字符串到`控制台(标准输入)`|`io.Writer`
2. 格式化字符串 `Sprint`
3. 格式化占位符
4. 从`控制台(标准输入)`|`io.Reader`|`字符串`获取输入
5. 自定义异常类 `fmt.Errorf()`

## 输出

标准库 fmt 提供了以下几种输出相关函数。

```go
//Print 系列函数会将内容输出到系统的标准输出，区别在于 Print 函数直接输出内容，Printf 函数支持格式化输出字符串，Println 函数会在输出内容的结尾添加一个换行符。
func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
// Fprint 系列函数会将内容输出到一个 io.Writer 接口类型的变量 w 中，我们通常用这个函数往文件中写入内容。
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
// Sprint 格式化字符串
func Sprint(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string
func Sprintln(a ...interface{}) string

// Errorf 函数根据 format 参数生成格式化字符串并返回一个包含该字符串的错误
func Errorf(format string, a ...interface{}) error
```

## 输入

Go 语言 fmt 包下有 fmt.Scan、fmt.Scanf、fmt.Scanln 三个函数，可以在程序运行过程中从标准输入获取用户的输入。

```go
// 标准输入
// Scan 从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。
func Scan(a ...interface{}) (n int, err error)
// Scanf 从标准输入扫描文本，根据 format 参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。
func Scanf(format string, a ...interface{}) (n int, err error)
//Scanln 类似 Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。
func Scanln(a ...interface{}) (n int, err error)
// 自定义输入
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
// 从指定字符串中读取数据
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)

var str1, str2 string
fmt.Sscan("str string", &str1, &str2)
fmt.Sscanf("str,string", "%s,%s", &str1, &str2)
fmt.Sscanln("str string", &str1, &str2)
fmt.Println(str1, str2)
```

## 格式化占位符

`*printf`系列函数都支持 format 格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。

| 占位符 | 说明                                                                     |
| ------ | ------------------------------------------------------------------------ |
| %v     | 值的默认格式表示                                                         |
| %+v    | 类似%v，但输出结构体时会添加字段名                                       |
| %#v    | 值的 Go 语法表示                                                         |
| %T     | 打印值的类型                                                             |
| %%     | 百分号                                                                   |
| %t     | true 或 false                                                            |
| %b     | 表示为二进制                                                             |
| %c     | 该值对应的 unicode 码值                                                  |
| %d     | 表示为十进制                                                             |
| %o     | 表示为八进制                                                             |
| %x     | 表示为十六进制，使用 a-f                                                 |
| %X     | 表示为十六进制，使用 A-F                                                 |
| %U     | 表示为 Unicode 格式：U+1234，等价于”U+%04X”                              |
| %q     | 该值对应的单引号括起来的 go 语法字符字面值，必要时会采用安全的转义表示   |
| %b     | 无小数部分、二进制指数的科学计数法，如-123456p-78                        |
| %e     | 科学计数法，如-1234.456e+78                                              |
| %E     | 科学计数法，如-1234.456E+78                                              |
| %f     | 有小数部分但无指数部分，如 123.456                                       |
| %F     | 等价于%f                                                                 |
| %g     | 根据实际情况采用%e 或%f 格式（以获得更简洁、准确的输出）                 |
| %G     | 根据实际情况采用%E 或%F 格式（以获得更简洁、准确的输出）                 |
| %s     | 直接输出字符串或者[]byte                                                 |
| %q     | 该值对应的双引号括起来的 go 语法字符串字面值，必要时会采用安全的转义表示 |
| %x     | 每个字节用两字符十六进制数表示（使用 a-f                                 |
| %X     | 每个字节用两字符十六进制数表示（使用 A-F）                               |
| %p     | 表示为十六进制，并加上前导的 0x                                          |

### 宽度标识符

宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为 0。举例如下

| 占位符 | 说明               |
| ------ | ------------------ |
| %f     | 默认宽度，默认精度 |
| %9f    | 宽度 9，默认精度   |
| %.2f   | 默认宽度，精度 2   |
| %9.2f  | 宽度 9，精度 2     |
| %9.f   | 宽度 9，精度 0     |

### 其他标识符

```go
+ //总是输出数值的正负号
  //空格,对数值，正数前加空格而负数前加负号；对字符串采用%x 或%X 时（% x 或% X）会给各打印的字节之间加空格
- //在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐
# //进制,8+0,16+0x,指针去除0x,对%U（%#U）会输出空格和单引号括起来的 go 字面值
0 // 使用 0 而不是空格填充，对于数值类型会把填充的 0 放在正负号后面
```

## bufio.NewReader 完整获取输入的内容

有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用 bufio 包来实现。示例代码如下：

```go
func bufioDemo() {
    reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象
    fmt.Print("请输入内容：")
    text, _ := reader.ReadString('\n') // 读到换行
    text = strings.TrimSpace(text)
    fmt.Printf("%#v\n", text)
}
```

# 异常

1. errors
2. 自定义异常类 `fmt.Errorf()`

# io 操作

## io

## ioutil

## bufio

## os 标准输入输出流

## path

## filepath

# 时间与日期

时间和日期是我们编程中经常会用到的，本文主要介绍了 Go 语言内置的 time 包的基本用法。

1. `time`

```go
// time
now := time.Now() //获取当前时间
fmt.Printf("current time:%v\n", now)

year := now.Year()     //年
month := now.Month()   //月
day := now.Day()       //日
hour := now.Hour()     //小时
minute := now.Minute() //分钟
second := now.Second() //秒
fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)

```

### 3. 时间戳

时间戳是自 1970 年 1 月 1 日（08:00:00GMT）至当前时间的总毫秒数。它也被称为 Unix 时间戳（UnixTimestamp）。

基于时间对象获取时间戳的示例代码如下：

```go
func timestampDemo() {
    now := time.Now()            //获取当前时间
    timestamp1 := now.Unix()     //时间戳
    timestamp2 := now.UnixNano() //纳秒时间戳
    fmt.Printf("current timestamp1:%v\n", timestamp1)
    fmt.Printf("current timestamp2:%v\n", timestamp2)
}
```

使用 time.Unix()函数可以将时间戳转为时间格式。

```go
func timestampDemo2(timestamp int64) {
    timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式
    fmt.Println(timeObj)
    year := timeObj.Year()     //年
    month := timeObj.Month()   //月
    day := timeObj.Day()       //日
    hour := timeObj.Hour()     //小时
    minute := timeObj.Minute() //分钟
    second := timeObj.Second() //秒
    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)
}
```

### 4. 时间间隔

time.Duration 是 time 包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration 表示一段时间间隔，可表示的最长时间段大约 290 年。

time 包中定义的时间间隔类型的常量如下：

```go
const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)
```

例如：time.Duration 表示 1 纳秒，time.Second 表示 1 秒。

### 5. 时间操作

#### Add

我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go 语言的时间对象有提供 Add 方法如下：

```
    func (t Time) Add(d Duration) Time
```

举个例子，求一个小时之后的时间：

```go
func main() {
    now := time.Now()
    later := now.Add(time.Hour) // 当前时间加1小时后的时间
    fmt.Println(later)
}
```

#### Sub

求两个时间之间的差值：

```
    func (t Time) Sub(u Time) Duration
```

返回一个时间段 t-u。如果结果超出了 Duration 可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点 t-d（d 为 Duration），可以使用 t.Add(-d)。

#### Equal

```
    func (t Time) Equal(u Time) bool
```

判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用 t==u 不同，这种方法还会比较地点和时区信息。

#### Before

```
    func (t Time) Before(u Time) bool
```

如果 t 代表的时间点在 u 之前，返回真；否则返回假。

#### After

```
    func (t Time) After(u Time) bool
```

如果 t 代表的时间点在 u 之后，返回真；否则返回假。

### 6. 定时器

使用 time.Tick(时间间隔)来设置定时器，定时器的本质上是一个通道（channel）。

```go
func tickDemo() {
    ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器
    for i := range ticker {
        fmt.Println(i)//每秒都会执行的任务
    }
}
```

### 7. 时间格式化

时间类型有一个自带的方法 Format 进行格式化，需要注意的是 Go 语言中格式化时间模板不是常见的 Y-m-d H:M:S 而是使用 Go 的诞生时间 2006 年 1 月 2 号 15 点 04 分（记忆口诀为 2006 1 2 3 4）。也许这就是技术人员的浪漫吧。

补充：如果想格式化为 12 小时方式，需指定 PM。

```go
func formatDemo() {
    now := time.Now()
    // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan
    // 24小时制
    fmt.Println(now.Format("2006-01-02 15:04:05.000 Mon Jan"))
    // 12小时制
    fmt.Println(now.Format("2006-01-02 03:04:05.000 PM Mon Jan"))
    fmt.Println(now.Format("2006/01/02 15:04"))
    fmt.Println(now.Format("15:04 2006/01/02"))
    fmt.Println(now.Format("2006/01/02"))
}
```

#### **解析字符串格式的时间**

```go
now := time.Now()
fmt.Println(now)
// 加载时区
loc, err := time.LoadLocation("Asia/Shanghai")
if err != nil {
    fmt.Println(err)
    return
}
// 按照指定时区和指定格式解析字符串时间
timeObj, err := time.ParseInLocation("2006/01/02 15:04:05", "2019/08/04 14:15:20", loc)
if err != nil {
    fmt.Println(err)
    return
}
fmt.Println(timeObj)
fmt.Println(timeObj.Sub(now))
```

# 文件读写

读取的文件放在 file/test：也就是 file 包下的 test 这个文件，里面写多一点文件

- 读文件方式一：利用 ioutil.ReadFile 直接从文件读取到[]byte 中

```go
func Read0()  (string){
    f, err := ioutil.ReadFile("file/test")
    if err != nil {
        fmt.Println("read fail", err)
    }
    return string(f)
}
```

- 读文件方式二：先从文件读取到 file 中，在从 file 读取到 buf, buf 在追加到最终的[]byte

```go
func Read1()  (string){
    //获得一个file
    f, err := os.Open("file/test")
    if err != nil {
        fmt.Println("read fail")
        return ""
    }

    //把file读取到缓冲区中
    defer f.Close()
    var chunk []byte
    buf := make([]byte, 1024)

    for {
        //从file读取到buf中
        n, err := f.Read(buf)
        if err != nil && err != io.EOF{
            fmt.Println("read buf fail", err)
            return ""
        }
        //说明读取结束
        if n == 0 {
            break
        }
        //读取到最终的缓冲区中
        chunk = append(chunk, buf[:n]...)
    }

    return string(chunk)
    //fmt.Println(string(chunk))
}
```

- 读文件方式三：先从文件读取到 file, 在从 file 读取到 Reader 中，从 Reader 读取到 buf, buf 最终追加到[]byte

```go
//先从文件读取到file, 在从file读取到Reader中，从Reader读取到buf, buf最终追加到[]byte，这个排第三
func Read2() (string) {
    fi, err := os.Open("file/test")
    if err != nil {
        panic(err)
    }
    defer fi.Close()

    r := bufio.NewReader(fi)
    var chunks []byte

    buf := make([]byte, 1024)

    for {
        n, err := r.Read(buf)
        if err != nil && err != io.EOF {
            panic(err)
        }
        if 0 == n {
            break
        }
        //fmt.Println(string(buf))
        chunks = append(chunks, buf...)
    }
    return string(chunks)
    //fmt.Println(string(chunks))
}
```

- 读文件方式四：读取到 file 中，再利用 ioutil 将 file 直接读取到[]byte 中

```go
//读取到file中，再利用ioutil将file直接读取到[]byte中, 这是最优
func Read3()  (string){
    f, err := os.Open("file/test")
    if err != nil {
        fmt.Println("read file fail", err)
        return ""
    }
    defer f.Close()

    fd, err := ioutil.ReadAll(f)
    if err != nil {
        fmt.Println("read to fd fail", err)
        return ""
    }

    return string(fd)
}
```

#### **读取速度比较**

经过我的测试，这四种方式读的速度排名是：前者为优
方式四 > 方式一 > 方式三 > 方式四

### **写文件**

- 写文件方式一：使用 io.WriteString 写入文件

```go
func Write0()  {
    fileName := "file/test1"
    strTest := "测试测试"

    var f *os.File
    var err error

    if CheckFileExist(fileName) {  //文件存在
        f, err = os.OpenFile(fileName, os.O_APPEND, 0666) //打开文件
        if err != nil{
            fmt.Println("file open fail", err)
            return
        }
    }else {  //文件不存在
        f, err = os.Create(fileName) //创建文件
        if err != nil {
            fmt.Println("file create fail")
            return
        }
    }
    //将文件写进去
    n, err1 := io.WriteString(f, strTest)
    if err1 != nil {
        fmt.Println("write error", err1)
        return
    }
    fmt.Println("写入的字节数是：", n)
}
```

- 写文件方式二：使用 ioutil.WriteFile 写入文件

```css
func Write1()  {
    fileName := "file/test2"
    strTest := "测试测试"
    var d = []byte(strTest)
    err := ioutil.WriteFile(fileName, d, 0666)
    if err != nil {
        fmt.Println("write fail")
    }
    fmt.Println("write success")
}
```

- 写文件方式三：使用 File(Write,WriteString) 写入文件

```go
func Write2()  {

    fileName := "file/test3"
    strTest := "测试测试"
    var d1 = []byte(strTest)

    f, err3 := os.Create(fileName) //创建文件
    if err3 != nil{
        fmt.Println("create file fail")
    }
    defer f.Close()
    n2, err3 := f.Write(d1) //写入文件(字节数组)

    fmt.Printf("写入 %d 个字节n", n2)
    n3, err3 := f.WriteString("writesn") //写入文件(字节数组)
    fmt.Printf("写入 %d 个字节n", n3)
    f.Sync()
}
```

- 写文件方式四：使用 bufio.NewWriter 写入文件

```go
func Write3()  {
    fileName := "file/test3"
    f, err3 := os.Create(fileName) //创建文件
    if err3 != nil{
        fmt.Println("create file fail")
    }
    w := bufio.NewWriter(f) //创建新的 Writer 对象
    n4, err3 := w.WriteString("bufferedn")
    fmt.Printf("写入 %d 个字节n", n4)
    w.Flush()
    f.Close()
}
```

- 检查文件是否存在：

```go
func CheckFileExist(fileName string) bool {
    _, err := os.Stat(fileName)
    if os.IsNotExist(err) {
        return false
    }
    return true
}
```

# unsafe

# syscall

```go

```

# 资料

1. [Go 教程](https://cloud.tencent.com/developer/doc/1101)
