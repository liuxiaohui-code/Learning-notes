# 使用步骤

1. `npm install -g typescript`
2. 编写 typescript 代码: greeter.ts
3. `tsc greeter.ts` 生成 greeter.js
4. 调用 greeter.js

# 类型注解

1. 使用在变量后面,语法:`参数:类型`
2. 类型:
   1. 字符串: `string`
   2. 布尔值:`boolean`
   3. 数字:`number`
   4. 数组:`Array<元素类型>`或`元素类型[]`
   5. 元组:`[type1,type2,...]`,表示一个已知元素数量和类型的数组，各元素的类型不必相同
   6. 枚举:`enum Color {Red, Green, Blue};let c: Color = Color.Green;`
   7. `any` 不检查类型
   8. `void` 常用在函数返回值,表示函数无返回,只能为它赋予 undefined 和 null
   9. `undefined` `null`,默认情况下 null 和 undefined 是所有类型的子类型。然而，当你指定了--strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefined。`变量!`表示去除 undefined 和 null
   10. `never` 表示用不存在的值,比如函数抛出异常,永远获取不到返回值
   11. `object` 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。
3. 类型断言:
   1. <> `let strLength: number = (<string>someValue).length;` // any -> string
   2. as `let strLength: number = (someValue as string).length;`
4. 复杂类型
   1. 交叉 `Person & Serializable & Loggable` 同时具有以上类型成员的类型
   2. 联合 `number | string | boolean` 可以是...的类型
      1. 字符串字面量 `type Easing = "ease-in" | "ease-out" | "ease-in-out";` 只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误
      2. 数字字面量 `1 | 2 | 3 | 4 | 5 | 6`
5. 类型别名 `type new_name = "type"`

```ts
function greeter(person: string) {
  return "Hello, " + person
}
```

# 接口 interface

## 隐式实现

```ts
// 不需要 implements ,只要对象有这个字段就算实现了这个接口
interface Person {
  firstName: string
  lastName: string
  color?: string // 可选属性
  width?: number
  readonly x: number // 只读
  readonly y: number
  [propName: string]: any // 还具有其他属性
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName
}

let user = { firstName: "Jane", lastName: "User" }

document.body.innerHTML = greeter(user)

// 描述一个函数
interface SearchFunc {
  (source: string, subString: string): boolean // (参数):返回
}
// 描述一个可索引的类型
interface StringArray {
  [index: number]: string // 字符串数组

  //TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。
}
```

## 实现接口

```ts
interface ClockInterface {
  currentTime: Date
  setTime(d: Date)
}

class Clock implements ClockInterface {
  currentTime: Date
  setTime(d: Date) {
    this.currentTime = d
  }
  constructor(h: number, m: number) {}
}
```

## 继承接口

```ts
interface Shape {
  color: string
}

interface PenStroke {
  penWidth: number
}

interface Square extends Shape, PenStroke {
  sideLength: number
}

let square = <Square>{}
square.color = "blue"
square.sideLength = 10
square.penWidth = 5.0
```

# 类 class

```ts
// ts 支持 js 新特性
class Student {
  fullName: string
  constructor(public firstName, public middleInitial, public lastName) {
    this.fullName = firstName + " " + middleInitial + " " + lastName
  }
}

interface Person {
  firstName: string
  lastName: string
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName
}

let user = new Student("Jane", "M.", "User")

document.body.innerHTML = greeter(user)
```

## 继承

1. 继承`extends`
2. ts 强制要求,子类构造函数需要首先执行`super(...)`

```ts
class Animal {
  name: string
  constructor(theName: string) {
    this.name = theName
  }
  move(distanceInMeters: number = 0) {
    console.log(`${this.name} moved ${distanceInMeters}m.`)
  }
}

class Snake extends Animal {
  constructor(name: string) {
    super(name)
  }
  move(distanceInMeters = 5) {
    console.log("Slithering...")
    super.move(distanceInMeters)
  }
}

class Horse extends Animal {
  constructor(name: string) {
    super(name)
  }
  move(distanceInMeters = 45) {
    console.log("Galloping...")
    super.move(distanceInMeters)
  }
}

let sam = new Snake("Sammy the Python")
let tom: Animal = new Horse("Tommy the Palomino")

sam.move()
tom.move(34)
```

## 修饰符

1. 在 TypeScript 里，成员都默认为 `public` 。
2. 当成员被标记成 `private` 时，它就不能在声明它的类的外部访问。
3. `protected` 修饰符与 private 修饰符的行为很相似，但有一点不同， protected 成员在派生类中仍然可以访问。
4. `readonly` 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。
5. `static` 静态属性,使用`类名.`访问
6. `abstract` 抽象类+抽象方法

```ts
class Animal {
  public name: string
  readonly numberOfLegs: number = 8
  static origin = { x: 0, y: 0 }
  public constructor(theName: string) {
    this.name = theName
  }
  public move(distanceInMeters: number) {
    console.log(`${this.name} moved ${distanceInMeters}m.`)
  }
}
```

# 函数

```ts
let myAdd: (x: number, y: number) => number = function(x: number, y: number): number { return x + y; }; // 返回值类型
let myAdd2: function(x: number, y: number):number = function(x,y){return x+y;} // 类型推断
function buildName(firstName: string, lastName?: string) // ? 可选参数
function buildName(firstName: string, lastName = "Smith") // 默认参数
function buildName(firstName: string, ...restOfName: string[]) // ... 剩余参数
// 方法重载
function pickCard(x: {suit: string; card: number; }[]): number; // 重载声明
function pickCard(x: number): {suit: string; card: number; }; // 重载声明
function pickCard(x): any {...} // 函数体
```

# 泛型

```ts
// 泛型参数
function identity<T>(arg: T): T {
  return arg
}
let output = identity<string>("myString")
let output = identity("myString")
// 泛型类, 类的静态属性不能使用这个泛型类型。
class GenericNumber<T> {
  zeroValue: T
  add: (x: T, y: T) => T
}
let myGenericNumber = new GenericNumber<number>()
// 泛型约束
interface Lengthwise {
  length: number
}
function loggingIdentity<T extends Lengthwise>(arg: T): T {
  // 泛型必须有一个length属性
  console.log(arg.length) // Now we know it has a .length property, so no more error
  return arg
}
```

# 枚举

TypeScript 支持数字的和基于字符串的枚举。

```ts
enum Direction {
  Up = 1, // 数字,默认从0开始增长
  Down,
  Left,
  Right,
}
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}
enum FileAccess {
  // constant members
  None,
  Read = 1 << 1,
  Write = 1 << 2,
  ReadWrite = Read | Write,
  // computed member
  G = "123".length,
}
```

# 模块

## import 与 export

## export = 和 import = require()

CommonJS 和 AMD 的环境里都有一个 `exports` 变量，这个变量包含了一个模块的所有导出内容。

CommonJS 和 AMD 的 `exports` 都可以被赋值为一个对象, 这种情况下其作用就类似于 es6 语法里的默认导出，即 export default 语法了。虽然作用相似，但是 export default 语法并不能兼容 CommonJS 和 AMD 的 exports。

为了支持 CommonJS 和 AMD 的 exports, TypeScript 提供了 `export =`语法。

export =语法定义一个模块的导出对象。 这里的对象一词指的是类，接口，命名空间，函数或枚举。

若使用 export =导出一个模块，则必须使用 TypeScript 的特定语法 `import module = require("module")`来导入此模块。

# tsconfig.json

如果一个目录下存在一个 tsconfig.json 文件，那么它意味着这个目录是 TypeScript 项目的根目录。 tsconfig.json 文件中指定了用来编译这个项目的根文件和编译选项。

如果"files"和"include"都没有被指定，编译器默认包含当前目录和子目录下所有的 TypeScript 文件（.ts, .d.ts 和 .tsx），排除在"exclude"里指定的文件。

```json
// 使用 files
{
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitAny": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": true
  },
  "files": [
    "core.ts",
    "sys.ts",
    "types.ts",
    "scanner.ts",
    "parser.ts",
    "utilities.ts",
    "binder.ts",
    "checker.ts",
    "emitter.ts",
    "program.ts",
    "commandLineParser.ts",
    "tsc.ts",
    "diagnosticInformationMap.generated.ts"
  ]
}
// 或 使用 include 和 exclude
{
    "compilerOptions": {  // 编译选项 https://www.tslang.cn/docs/handbook/compiler-options.html
        "module": "system",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "outFile": "../../built/local/tsc.js",
        "sourceMap": true
    },
    "include": [  // * 匹配0或多个字符（不包括目录分隔符）? 匹配一个任意字符（不包括目录分隔符）**/ 递归匹配任意子目录
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.spec.ts"
    ]
}
```
