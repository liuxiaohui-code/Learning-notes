# String

1. 引用类型,可以直接使用`""`创建对象;
2. 实际上字符串在 `String` 内部是通过一个 `char[]`数组表示的
3. 字符串不可变,这种不可变性是通过内部的`private final char[]`字段，以及没有任何修改`char[]`的方法实现的。
4. 字符串比较:必须使用`equals() equalsIgnoreCase()` 方法而不能用`==`。Java 编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池,因此 `"hello" == "hello"`为真;
5. 空白字符处理:
   1. `trim()`,去除首尾空白字符,空白字符包括`空格，\t，\r，\n`
   2. `strip()`,去除首尾空白字符,除了`trim()`的空格外,类似中文的空格字符`\u3000`也会被移除
   3. `isEmpty()` 判断字符串是否为空 `""`
   4. `isBlank()` 判断字符串是否为空白字符串,`"\n"`
6. 字符串替换: `replace()` `replaceAll(正则)`
7. 分割: `split(正则)`
8. 拼接: `join()` 指定的字符串连接字符串数组
9. 类型转换: `valueOf()` 和 基本类型包装类的`xxParse()`方法
10. `char[]` 相互转换
    1. `char[] cs = "Hello".toCharArray(); // String -> char[]`
    2. `String s = new String(cs); // char[] -> String` 如果修改了 char[]数组，String 并不会改变,是因为是复制了一份 char[]而不是引用

```java
// "" 字面量表示字符串
String s = ""; // 空字符串，包含0个字符
String s1 = "A"; // 包含一个字符
String s2 = "ABC"; // 包含3个字符
String s3 = "中文 ABC"; // 包含6个字符，其中有一个空格
// char[] 表示字符串
String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'});
```

## 转义字符

\" 表示字符"
\' 表示字符'
\ 表示字符\
\n 表示换行符
\r 表示回车符
\t 表示 Tab
\u#### 表示一个 Unicode 编码的字符

## 字符串连接

```java
// + ,Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型
String a = "1"+"xxx";
// 如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接
String a = 1+"xxx";
//如果我们要表示多行字符串，使用+号连接会非常不方便：
String s = "first line \n"
         + "second line \n"
         + "end";
// 从Java 13开始，字符串可以用"""…"""表示多行字符串（Text Blocks）了
String s = """
         first line
         second line
         end """
// 还需要注意到，多行字符串前面共同的空格会被去掉,如果多行字符串的排版不规则,总是以最短的行首空格为基准.

//最后，由于多行字符串是作为Java 13的预览特性（Preview Language Features）实现的，编译的时候，我们还需要给编译器加上参数：
javac --source 13 --enable-preview Main.java
```

## 字符编码

`ASCII` 美国国家标准学会（American National Standard Institute：ANSI）制定了一套**英文字母、数字和常用符号**的编码，它占用**一个字节**，编码范围从**0 到 127**，**最高位始终为 0**
`GB2312` 标准使用**两个字节**表示一个汉字，其中**第一个字节的最高位始终为 1**，以便和 ASCII 编码区分开。
`Unicode` 全球统一码联盟,它把世界上主要语言都纳入同一个编码,需要**两个或者更多字节**
`UTF-8` 变长编码，用来**把固定长度的 Unicode 编码变成 1 ～ 4 字节的变长编码**。ASCII 一个字节,汉字三个字节,**依靠高字节位来确定一个字符究竟是几个字节**，它经常用来作为传输编码。

在 Java 中，`char` 类型实际上就是**两个字节的 Unicode 编码**。如果我们要手动把字符串转换成其他编码，可以这样做：

```Java
byte[] b1 = "Hello".getBytes(); // 按 ISO8859-1 编码转换，不推荐
byte[] b2 = "Hello".getBytes("UTF-8"); // 按 UTF-8 编码转换
byte[] b2 = "Hello".getBytes("GBK"); // 按 GBK 编码转换
byte[] b3 = "Hello".getBytes(StandardCharsets.UTF_8); // 按 UTF-8 编码转换
```

## 字符集 StandardCharsets

Java 字符集标准类:`java.nio.charset.StandardCharsets`

# StringBuilder

`+` 虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响 GC 效率。
为了能**高效拼接字符串**，Java 标准库提供了`StringBuilder`，它是**一个可变对象，可以预分配缓冲区**，这样，**往 StringBuilder 中新增字符时，不会创建新的临时对象**

```java
StringBuilder sb = new StringBuilder(1024);
for (int i = 0; i < 1000; i++) {
    sb.append(',');
    sb.append(i);
}
String s = sb.toString();

// 链式操作
String result  = new StringBuilder(1024).append("x1").append("x2").insert(0,"hello , ").toString()
```

注意：对于普通的字符串+操作，并不需要我们将其改写为 StringBuilder，因为 Java 编译器在编译时就自动把多个连续的+操作编码为 StringConcatFactory 的操作。在运行期，StringConcatFactory 会自动把字符串连接操作优化为数组复制或者 StringBuilder 操作。

# StringBuffer

`StringBuffer` ，这是 Java 早期的一个 `StringBuilder` 的线程安全版本，它通过同步来保证多个线程操作 `StringBuffer` 也是安全的，但是同步会带来执行速度的下降。
`StringBuilder` 和 `StringBuffer` 接口完全相同，现在完全没有必要使用 `StringBuffer`

# StringJoiner

用于构造由分隔符分隔的字符序列，并且可选地以提供的前缀开头并以提供的后缀结束。

```java
String[] names = {"A","B","C","D"};
var sj = new StringJoiner(", ","hello , "," !");// 设置分割符,前缀,后缀
for(String name : names){
  sj.add(name);
}
System.out.println(sj.toString()); // hello , A, B, C, D !
```

`String`还提供了一个静态方法`join()`，这个方法在内部使用了 StringJoiner 来拼接字符串，在**不需要指定“开头”和“结尾”的时候，用`String.join()`更方便**

# 正则表达式支持

## regex

正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则。Java 标准库 `java.util.regex` 内建了正则表达式引擎。

1. `java.util.regex.Pattern` 定义正则表达式
2. `java.util.regex.Matcher` 使用正则表达式进行操作
3. 匹配整个字符串 matches()
4. 匹配子串 find()
5. 匹配到的子串的索引 start() end()
6. 分组匹配: 正则表达式使用()将一个正则表达式分成多个子表达式,首先整个正则表达式匹配成功后,将会匹配子串
7. 反向引用: replaceAll​() 的第二个参数中可以用$1 $2 代替第一个参数匹配到的子串

基本使用

```java
// Pattern
// 定义正则表达式
static Pattern compile(String regex);
static Pattern compile​(String regex, int flags);
// 获得 Matcher
Matcher matcher("要匹配的字符串");

// Matcher
// 匹配整个串
boolean matches() ;
// 分组匹配,在matches执行之后
String group​(int group) ;
// 查找匹配政策表达式的子串
boolean find() ; // true时,
```

```java
// 分组匹配
Pattern p = Pattern.compile("(\\d{3,4})-(\\d{6,8})");
Matcher m = p.matcher("010-1234578");
if (m.matches()) {
  // 使用Matcher时，必须首先调用matches()判断是否匹配成功，匹配成功后，才能调用group()提取子串。
    System.out.println(m.group(0)); //010-1234578  整个正则表达式匹配到的结果
    System.out.println(m.group(1)); //010   第一个括号的子串
    System.out.println(m.group(2)); //12345678 第二个括号匹配的子串
} else {
    System.out.println("匹配失败");
}
// 查找子串
String s = "the hello world xxx lazy dog 你好";
Matcher matcher = Pattern.compile("\\wo\\w").matcher(s);
while (matcher.find()) {
    String sub = s.substring(matcher.start(), matcher.end());
    System.out.println(sub);
}
//wor
//dog
```

正则表达式默认使用**贪婪匹配**：任何一个规则，它总是尽可能多地向后匹配，给定一个匹配规则，在限定符后加上`?`后就变成了**非贪婪匹配**。

## String

```java
// 字符串完全被正则匹配时,返回true, 内部实现 Pattern.matches(regex, this);
// 但是反复使用String.matches()对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的Pattern对象。完全可以先创建出一个Pattern对象，然后反复使用，就可以实现编译一次，多次匹配
boolean matches("regex");
// 分割
String[] split(String regex);
// 替换
String replaceAll​(String regex, String replacement);
String replaceFirst​(String regex, String replacement);
// 支持反向引用

Assertions.assertEquals(true, "asd asvdsg name hello year" .matches("^[\\s\\S]+hello [\\s\\S]+"));

System.out.println(Arrays.toString("a b c".split("\\s"))); // [a, b, c]
System.out.println(Arrays.toString("a b  c".split("\\s"))); // [a, b, , c]
System.out.println(Arrays.toString("a, b ;; c".split("[\\,\\;\\s]+"))); // [a, b, c]

// 反向引用

```
