
# 模块 Java9

我们知道，`.class` 文件是 JVM 看到的最小可执行文件，而一个大型程序需要编写很多 Class ，并生成一堆.class 文件，很不便于管理，所以，jar 文件就是 class 文件的容器。

在 Java 9 之前，一个大型 Java 程序会生成自己的 jar 文件，同时引用依赖的第三方 jar 文件，而 JVM 自带的 Java 标准库，实际上也是以 jar 文件形式存放的，这个文件叫 rt.jar，一共有 60 多 M。

如果是自己开发的程序，除了一个自己的 app.jar 以外，还需要一堆第三方的 jar 包，运行一个 Java 程序，一般来说，命令行写这样：`java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main`

**所以，jar 只是用于存放 class 的容器，它并不关心 class 之间的依赖。**

**从 Java 9 开始引入的模块，主要是为了解决“依赖”这个问题。**如果 a.jar 必须依赖另一个 b.jar 才能运行，那我们应该给 a.jar 加点说明啥的，让程序在编译和运行的时候能自动定位到 b.jar，这种自带“依赖关系”的 class 容器就是模块。

为了表明 Java 模块化的决心，从 Java 9 开始，原有的 Java 标准库已经由一个单一巨大的 `rt.jar` 分拆成了几十个模块，这些模块以`.jmod` 扩展名标识，可以在`$JAVA_HOME/jmods` 目录下找到它们：

```
java.base.jmod
java.compiler.jmod
java.datatransfer.jmod
java.desktop.jmod
…
```

这些`.jmod` 文件每一个都是一个模块，模块名就是文件名。例如：模块 `java.base` 对应的文件就是 `java.base.jmod`。模块之间的依赖关系已经被写入到模块内的 `module-info.class` 文件了。**所有的模块都直接或间接地依赖 java.base 模块，只有 java.base 模块不依赖任何模块，它可以被看作是“根模块”**，好比所有的类都是从 Object 直接或间接继承而来。

把一堆 class 封装为 jar 仅仅是一个打包的过程，而把一堆 class 封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是 JNI 扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的 JVM 提供不同的版本。

### 编写模块

```java
oop-module
├── bin
├── build.sh
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java


// module-info.java
module hello.world { // hello.world.jmod
    // requires 引入模块
    requires java.base; // 可不写，任何模块都会自动引入java.base
    requires java.xml;
}
```

```sh
# 编译字节码文件到 bin 目录
$javac -d bin src/module-info.java src/com/itranswarp/sample/*.java
# 把bin目录下的所有class文件先打包成jar,注意传入—main-class参数，让这个jar包能自己定位main方法所在的类
$jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .
# 现在我们就在当前目录下得到了hello.jar这个jar包，它和普通jar包并无区别，可以直接使用命令 来运行它
$java -jar hello.jar
# 打包模块
$jmod create --class-path hello.jar hello.jmod
# 运行模块
$java --module-path hello.jar --module hello.world
Hello, xml!
```

### 用处

1. 打包 jre

过去发布一个 Java 应用程序，要运行它，必须下载一个完整的 JRE，再运行 jar 包。而完整的 JRE 块头很大，有 100 多 M。怎么给 JRE 瘦身呢？

现在，JRE 自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪 JRE 呢？并不是说把系统安装的 JRE 给删掉部分模块，而是“复制”一份 JRE，但只带上用到的模块。为此，JDK 提供了 jlink 命令来干这件事。命令如下：
`$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/`
我们在`—module-path`参数指定了我们自己的模块`hello.jmod`，然后，在`—add-modules`参数中指定了我们用到的 3 个模块`java.base`、`java.xml`和`hello.world`，用,分隔。最后，在`—output`参数指定输出目录。
现在，在当前目录下，我们可以找到 jre 目录，这是一个完整的并且带有我们自己 hello.jmod 模块的 JRE。试试直接运行这个 JRE：

```sh
$ jre/bin/java --module hello.world
Hello, xml!
```

要分发我们自己的 Java 应用程序，只需要把这个 jre 目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装 JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。

### 访问权限

class 的这些访问权限只在一个模块内有效，模块和模块之间，例如，a 模块要访问 b 模块的某个 class，必要条件是 b 模块明确地导出了可以访问的包。

```java
module hello.world {
    exports com.itranswarp.sample; // 到处外部访问需要的类
    requires java.base;
    requires java.xml;
}
```



