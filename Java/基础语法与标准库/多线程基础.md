# 名词解释

- **进程** 是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间
- **线程** 是进程中的一个执行路径，共享一个内存空间，线程之间可以自由切换，并发执行.
- **分时调度** 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
- **抢占式调度** 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)， Java 使用的为抢占式调度。
- **同步** 排队执行 , 效率低但是安全
- **异步** 同时执行 , 效率高但是数据不安全
- **并发** 指两个或多个事件在同一个时间段内发生
- **并行** 指两个或多个事件在同一时刻发生（同时发生）

**同一个应用程序**，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种:

1. 多进程模式（每个进程只有一个线程）
2. 多线程模式（一个进程有多个线程）
3. 多进程＋多线程模式（复杂度最高）

和多线程相比，多进程的**缺点**在于: 1. 创建进程比创建线程开销大，尤其是在 Windows 系统上；2. 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的**优点**在于: 多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。

java 程序中基本的线程:

1. main 主线程
2. gc 垃圾回收器线程

# 线程创建

Java 提供了三种创建线程的方法

## Thread

Thread: 实现了 Runnable 接口,底层使用静态代理模式用 Thread 代理了 Runnable

1. 继承 `Thread` 类,
2. 重写 `run()` 方法,
3. 调用 `start()` 开启线程,线程开启后由 CPU 调度执行

```java
@Test
public void createByThread() throws InterruptedException {
    class MyThread extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                System.out.println("MyThread-" + getName() + ": " + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    new MyThread().start();
    new MyThread().start();
    Thread.sleep(20000);
}
```

## Runnable

实现 Runnable 接口

1. 实现 Runnable 接口
2. 重写 run() 方法
3. 使用 Thread 接收 Runnable 对象
4. 调用 start() 启用线程

```java
@Test
public void createByRunnable() {
    Thread thread = new Thread(() -> {
        System.out.println("lambda 实现 Runnable 接口");
    });
    thread.start();
    System.out.println("主线程");
}
```

## Callable

1. 优点:
   1. 可以得到返回值
   2. 可以抛出异常
2. 缺点
   1. 实现较为复杂,需要线程池
3. 实现步骤:
   1. 实现 Callable 接口,需要返回值类型
   2. 重写 call() 方法,需要抛出异常
   3. 创建目标对象
   4. 创建执行服务 `ExecutoService ser = Executors.newFixedThreadPool(1)`
   5. 提交执行 `Future<Boolean> result1 = ser.submit(t1);`
   6. 获取结果 `boolean r1 = result1.get()`
   7. 关闭服务 `ser.shutdownNow()`

```java
public class MyCallable implements Callable<T>{
   @Override
   public T call(){
      //线程体
      return T;
   }

   psvm(){
      new Thread(new MyRunnable()).start();
   }
}
```

# 线程状态

1. `New`: 新创建的线程，尚未执行 `new Thread()`；
2. `Runnable`: 运行中的线程，正在执行 `run()`方法的 Java 代码；
3. `Blocked`: 运行中的线程，因为某些操作被阻塞而挂起；
4. `Waiting`: 运行中的线程，因为某些操作在等待中；`join()`
5. `Timed Waiting`: 运行中的线程，因为执行 sleep()方法正在计时等待；
6. `Terminated`: 线程已终止，因为 run()方法执行完毕。 `interrupt()`

当线程启动后，它可以在 Runnable、Blocked、Waiting 和 Timed Waiting 这几个状态之间切换，直到最后变成 Terminated 状态，线程终止。

# 守护线程

守护线程是指为其他线程服务的线程。在 JVM 中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。

如何创建守护线程呢？方法和普通线程一样，只是在调用 start()方法前，调用 setDaemon(true)把该线程标记为守护线程:

```java
Thread t = new MyThread();
t.setDaemon(true);
t.start();
```

在守护线程中，编写代码要注意: 守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。

# volatile 及时同步共享变量

volatile 关键字解决的是可见性问题: 当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。

```java
volatile int x;
```

volatile 关键字的目的是告诉虚拟机:

1. 每次访问变量时，总是获取主内存的最新值；
2. 每次修改变量后，立刻回写到主内存。

# synchronized

## synchronized 同步代码块

执行同步代码块的逻辑:

1. 获取锁对象,检查此时锁对象是否正在使用
   1. 正在使用,则等待锁对象释放
   2. 空闲,则加锁,锁对象被占用,代码块执行完毕,释放锁对象
2. 注意加锁对象必须是同一个实例；

```java
synchronized(object){
   // 同步代码块
   // 同步监视器: object
}
```

## jvm 规定的原子操作

0. 原子操作,不可分割的操作
1. 基本类型（long 和 double 除外）赋值，例如：int n = m；
2. 引用类型赋值，例如：List<String> list = anotherList。
3. long 和 double 是 64 位数据，JVM 没有明确规定 64 位赋值操作是不是一个原子操作，不过在 x64 平台的 JVM 是把 long 和 double 的赋值作为原子操作实现的。

```Java
// 原子操作相当于:
synchronized(object){
   int a = 1;
}
synchronized(object){
   Object  a = new Object();
}
```

## synchronized 同步方法

用 `synchronized` 修饰方法可以把整个方法变为同步代码块, `synchronized` 方法加锁对象是 `this`

```java
synchronized void method(){

}
// 相当于
void method(){
  synchronized(this){

  }
}
// 静态
public synchronized static void test(int n) {
    ...
}
//相当于
public static void test(int n) {
    synchronized(Counter.class) {
        ...
    }
}
```

线程安全类:

1. StringBuffer
2. 所有成员变量都是 `final` ,只能读不能写,比如 String，Integer，LocalDate
3. 只提供静态方法，没有成员变量的类: Math

## 可重入锁

1. **可重入锁**: 能被*同一个线程*反复获取的锁, Java 的线程锁是可重入的锁。
2. 由于 Java 的线程锁是可重入锁，所以，获取锁的时候，不但要*判断是否是第一次获取，还要记录这是第几次获取*。每获取一次锁，记录+1，每退出 `synchronized` 块，记录-1，减到 0 的时候，才会真正释放锁。

```java
public class Counter {
    private int count = 0;
    public synchronized void add(int n) {
        if (n < 0) {
            dec(-n);
        } else {
            count += n;
        }
    }
    public synchronized void dec(int n) {
        count += n;
    }
}
```

## 死锁

1. **死锁**:两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去;

```java
死锁出现的情况:
1. 执行 add(),获取 lockA,
2. 执行 dec(),获取 lockB,
3. 此时死锁,add()请求获得lockB的锁,获取不到,dec()请求获得lockA的锁,获取不到,同时所都无法释放

public void add(int m) {
    synchronized(lockA) { // 获得lockA的锁
        this.value += m;
        synchronized(lockB) { // 获得lockB的锁
            this.another += m;
        } // 释放lockB的锁
    } // 释放lockA的锁
}
public void dec(int m) {
    synchronized(lockB) { // 获得lockB的锁
        this.another -= m;
        synchronized(lockA) { // 获得lockA的锁
            this.value -= m;
        } // 释放lockA的锁
    } // 释放lockB的锁
}
```

# 线程控制

多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。

```java
Thread.sleep(1000);// 该线程暂停 1 秒
Thread.setPriority(int n); // 置线程的优先级,1~10, 默认值5,优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁

Thread t;
t.start();// 启动线程
t.join(); // 等待 t 执行完毕
t.join(1000); // 最多等待 t 执行 1000 毫秒,然后竞争
t.join(1000,1000); // 1000 毫秒,1000 纳秒
t.interrupt(); // 立即中断线程 t

Object obj; // 特指锁对象
obj.wait(); // 当前线程进入等待状态,等待唤醒,必须在synchronized块中才能调用wait()方法，因为wait()方法调用时，会释放线程获得的锁，wait()方法返回后，线程又会重新试图获得锁(重新竞争锁,但是会在获取锁后从 wait()方法之后开始执行 )。
obj.notify();  // 唤醒随机一个正在this锁等待的线程
obj.notifyAll(); // 唤醒所有当前正在this锁等待的线程
```

# concurrent

1. jdk5 后引入引入了一个高级的处理并发的`java.util.concurrent`包,它提供了大量更高级的并发功能，能大大*简化多线程程序的编写*。
2. `ReentrantLock` 替换 `synchronized`:synchronized 这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。使用 ReentrantLock 比直接使用 synchronized 更安全，线程在 tryLock()失败的时候不会导致死锁。

## ReentrantLock 替换 synchronized

```java
Lock lock = new ReentrantLock();
public func(){
  lock.lock();
  try {
    // access the resource protected by this lock
  } finally {
    lock.unlock();
  }
}

// 和synchronized不同的是，ReentrantLock可以尝试获取锁：
if (lock.tryLock(1, TimeUnit.SECONDS)) { //在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false
    try {
        ...
    } finally {
        lock.unlock();
    }
}

```

## Condition 实现线程唤醒/等待操作

synchronized 可以配合 wait 和 notify 实现线程在条件不满足时等待，条件满足时唤醒;使用 Condition 对象来实现 wait 和 notify 的功能

1. 从 `ReentrantLock` 锁获取 `Condition` 对象 `lock.newCondition();`
2. `await()` 等待唤醒
3. `signalAll()` 唤醒所有 condition.await()的线程,唤醒线程从 await()返回后需要重新获得锁。
4. `signal()` 唤醒其中一个

```java
class TaskQueue {
    // 锁对象
    private final Lock lock = new ReentrantLock();
    // 从锁获取condition对象
    private final Condition condition = lock.newCondition();
    private Queue<String> queue = new LinkedList<>();
    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            // 唤醒所有锁
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
    public String getTask() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
              // 等待唤醒
                condition.await();
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
```

## ReadWriteLock 读多写少

1. `ReadWriteLock` 允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待
2. 适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。

```java
public class Counter {
    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
    private final Lock rlock = rwlock.readLock();
    private final Lock wlock = rwlock.writeLock();
    private int[] counts = new int[10];
    public void inc(int index) {
        wlock.lock(); // 加写锁
        try {
            counts[index] += 1;
        } finally {
            wlock.unlock(); // 释放写锁
        }
    }
    public int[] get() {
        rlock.lock(); // 加读锁
        try {
            return Arrays.copyOf(counts, counts.length);
        } finally {
            rlock.unlock(); // 释放读锁
        }
    }
}

```

## StampedLock

StampedLock 和 ReadWriteLock 相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。

**乐观锁**的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。**悲观锁**则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。

1. 多个写操作同步 `stamp = stampedLock.writeLock() ` `stampedLock.unlockWrite(stamp);`
2. 读:
   1. 获取乐观锁 `long stamp = stampedLock.tryOptimisticRead();` 得到一个版本号
   2. 读取数据
   3. 检查乐观读锁后是否有其他写锁发生 `stampedLock.validate(stamp)` 验证版本号
      1. `true` 没有发生写入操作,数据安全,
      2. `false` 发生写入操作,数据不安全
         1. 获取一个悲观读锁 `stamp = stampedLock.readLock();`
         2. 读取数据
         3. 释放悲观读锁 `stampedLock.unlockRead(stamp);`
   4. 可以操作数据进行其他操作

```java
public class Point {
    private final StampedLock stampedLock = new StampedLock();
    private double x;
    private double y;
    public void move(double deltaX, double deltaY) {
        long stamp = stampedLock.writeLock(); // 获取写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            stampedLock.unlockWrite(stamp); // 释放写锁
        }
    }
    public double distanceFromOrigin() {
        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
        // 注意下面两行代码不是原子操作
        // 假设x,y = (100,200)
        double currentX = x;
        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)
        double currentY = y;
        // 此处已读取到y，如果没有写入，读取是正确的(100,200)
        // 如果有写入，读取是错误的(100,400)
        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生
            stamp = stampedLock.readLock(); // 获取一个悲观读锁
            try {
                currentX = x;
                currentY = y;
            } finally {
                stampedLock.unlockRead(stamp); // 释放悲观读锁
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
}
```

## 使用 Concurrent 线程安全的集合

使用 `java.util.concurrent` 包提供的线程安全的并发集合可以大大简化多线程编程：

多线程同时读写并发集合是安全的；

尽量使用 Java 标准库提供的并发集合，避免自己编写同步代码。

使用这些并发集合与使用非线程安全的集合类完全相同

```Java
interface	    non-thread-safe	          thread-safe
List	        ArrayList	                CopyOnWriteArrayList
Map	          HashMap	                  ConcurrentHashMap
Set	          HashSet / TreeSet	        CopyOnWriteArraySet
Queue	        ArrayDeque / LinkedList	  ArrayBlockingQueue / LinkedBlockingQueue
Deque	        ArrayDeque / LinkedList	  LinkedBlockingDeque
```

`java.util.Collections` 工具类还提供了一个旧的线程安全集合转换器，可以这么用：

```Java
Map unsafeMap = new HashMap();
Map threadSafeMap = Collections.synchronizedMap(unsafeMap);
```

但是它实际上是用一个包装类包装了非线程安全的 Map，然后对所有读写方法都用 `synchronized` 加锁，这样获得的线程安全集合的性能比 `java.util.concurrent` 集合要低很多，所以*不推荐使用*。

## 原子操作 Atomic

使用 `java.util.concurrent.atomic` 提供的原子操作可以简化多线程编程：

1. 原子操作实现了无锁的线程安全；
2. 适用于*计数器*，*累加器*等。

我们以 AtomicInteger 为例，它提供的主要操作有：

```Java
int addAndGet(int delta) // 增加值并返回新值：
int incrementAndGet() //加 1 后返回新值：
int get() //获取当前值：
int compareAndSet(int expect, int update) //用 CAS 方式设置：
```

Atomic 类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了 CAS：Compare and Set。

如果我们自己通过 CAS 编写 incrementAndGet()，它大概长这样：

```Java
public int incrementAndGet(AtomicInteger var) {
    int prev, next;
    do {
        prev = var.get();
        next = prev + 1;
    } while ( ! var.compareAndSet(prev, next));
    return prev;
}
CAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do … while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。
```

# ThreadLocal

我们可以在代码中调用 `Thread.currentThread()`获取当前线程。

Java 标准库提供了一个特殊的 ThreadLocal，它可以在一个线程中传递同一个对象。
实际上，可以把 ThreadLocal 看成一个全局`Map<Thread, Object>`：每个线程获取 ThreadLocal 变量时，总是使用 Thread 自身作为 key：因此，ThreadLocal 相当于给每个线程都开辟了一个独立的存储空间，各个线程的 ThreadLocal 关联的实例互不干扰。

为了保证能释放 ThreadLocal 关联的实例，我们可以通过 AutoCloseable 接口配合 try (resource) {…}结构，让编译器自动为我们关闭。

```java

static ThreadLocal<String> threadLocalUser = new ThreadLocal<>();

void processUser(user) {
    try {
        threadLocalUser.set(user);
        step1();
        step2();
        // 在 step1() step2() 中调用 get() 将返回同一个对象user
    } finally {
      // 最后，特别注意ThreadLocal一定要在finally中清除：
        threadLocalUser.remove();
    }
}
```

# 线程池

1. 提高响应速度(减少了创建新线程的时间)
2. 降低了资源消耗(重复利用线程池中线程,不需要每次都创建)
3. 线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。
4. 便于线程管理
   1. corePoolSize 核心池的大小
   2. maximumPoolSize 最大线程数
   3. keepAliveTime 线程没有任务时最多保持多长时间后会终止

# ExecutorService

`ExecutorService` Java 标准库提供了 ExecutorService 接口表示线程池,`Executors` 工具类\线程池的工厂类,用来创建并返回不同类型的线程池,常用实现类如下:

- 名词解释
- 线程创建
  - Thread
  - Runnable
  - Callable
- 线程状态
- 守护线程
- volatile 及时同步共享变量
- synchronized
  - synchronized 同步代码块
  - jvm 规定的原子操作
  - synchronized 同步方法
  - 可重入锁
  - 死锁
- 线程控制
- concurrent
  - ReentrantLock 替换 synchronized
  - Condition 实现线程唤醒/等待操作
  - ReadWriteLock 读多写少
  - StampedLock
  - 使用 Concurrent 线程安全的集合
  - 原子操作 Atomic
- ThreadLocal
- 线程池
- ExecutorService
  - FixedThreadPool 线程数固定的线程池
  - CachedThreadPool 线程数根据任务动态调整的线程池；
  - ScheduledThreadPool 定时执行任务
- Future
  - Callable 有返回值的线程
  - CompletableFuture
- ForkJoin 大任务拆分为多个并行任务

常用方法:

1. `submit()` 执行任务
2. `shutdown()`执行任务
3. `shutdownNow()`会立刻停止正在执行的任务
4. `awaitTermination()`则会等待指定的时间让线程池关闭。

## FixedThreadPool 线程数固定的线程池

```java
package com.lxh.threadDemo;

import org.junit.jupiter.api.Test;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorServiceDemo {
    @Test
    public void example() {
      // 创建线程池
        ExecutorService executor = Executors.newFixedThreadPool(3);
      // 添加线程任务
        executor.submit(new Task("高"));
        executor.submit(new Task("山"));
        executor.submit(new Task("流"));
      // 线程池满,等待其中一个线程执行完毕
        executor.submit(new Task("水"));
        // 关闭线程池
        executor.shutdown();
    }
}

class Task implements Runnable {
    public String name;

    public Task(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(name + "\t" + i);
        }
    }
}

```

## CachedThreadPool 线程数根据任务动态调整的线程池；

```java
@Test
public void example() {
    // 创建线程池
    int min = 4;
    int max = 10;
    // 线程池的大小限制在4～10个之间动态调整
    ExecutorService es = new ThreadPoolExecutor(min, max,
        60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
    // 添加线程任务
    executor.submit(new Task("高"));
    executor.submit(new Task("山"));
    executor.submit(new Task("流"));
    // 线程池满,等待其中一个线程执行完毕
    executor.submit(new Task("水"));
    // 关闭线程池
    executor.shutdown();
}
```

## ScheduledThreadPool 定时执行任务

```java
@Test
public void example() {
    // 创建线程池
    int min = 4;
    int max = 10;
    // 线程池的大小限制在4～10个之间动态调整
    ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);
    // 1秒后执行一次性任务:
    ses.schedule(new Task("one-time"), 1, TimeUnit.SECONDS);
    // 2秒后开始执行定时任务，每3秒执行:
    ses.scheduleAtFixedRate(new Task("fixed-rate"), 2, 3, TimeUnit.SECONDS);
    // 2秒后开始执行定时任务，以3秒为间隔执行:
    ses.scheduleWithFixedDelay(new Task("fixed-delay"), 2, 3, TimeUnit.SECONDS);
}
```

1. `scheduleAtFixedRate` ，是以上一个任务开始的时间计时，3 秒过去后，检测上一个任务是否执行完毕，如果上一个任务执行完毕，则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行。
2. `scheduleWithFixedDelay` ，是以上一个任务结束时开始计时，3 秒过去后，立即执行。
3. 如果其中有一次任务抛出异常而未被处理,那么定时任务将会卡在错误那一行,不会继续进行,程序也不会报错,也不会停止

Java 标准库还提供了一个 `java.util.Timer` 类，这个类也可以定期执行任务，但是，一个 `Timer` 会对应一个 `Thread` ，所以，一个 `Timer` 只能定期执行一个任务，多个定时任务必须启动多个 `Timer` ，而一个 `ScheduledThreadPool` 就可以调度多个定时任务，所以，我们完全可以用 `ScheduledThreadPool` 取代旧的 `Timer` 。

# Future

## Callable 有返回值的线程

1. 实现 `Callable<T>` 接口,泛型为返回值类型
2. 任务放入线程池`submit()`得到 `Future` 对象
3. `future.get()` 在调用 get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么 get()会阻塞，直到任务完成后才返回结果。
   1. `get()`：获取结果（可能会等待）
   2. `get(long timeout, TimeUnit unit)`：获取结果，但只等待指定的时间；
   3. `cancel(boolean mayInterruptIfRunning)`：取消当前任务；
   4. `isDone()`：判断任务是否已完成。
4.

```java
@Test
public void example(){
  ExecutorService executor = Executors.newFixedThreadPool(4);
  // 定义任务:
  Callable<String> task = new Task();
  // 提交任务并获得Future:
  Future<String> future = executor.submit(task);
  // 从Future获取异步执行返回的结果:
  String result = future.get(); // 可能阻塞
}

class Task implements Callable<String> {
    public String call() throws Exception {
        return "";
    }
}
```

## CompletableFuture

使用 Future 获得异步执行结果时，要么调用阻塞方法 get()，要么轮询看 isDone()是否为 true，这两种方法都不是很好，因为主线程也会被迫等待。

从 `Java 8` 开始引入了 `CompletableFuture`,它针对 `Future` 做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。

1. 实现了异步回调机制,似 JavaScript 的 promise
   1. 创建: `supplyAsync()`
   2. 成功: `thenAccept()`
   3. 失败: `thenAccept()`
2. 多个 CompletableFuture 可以**串行执行**;例如，定义两个 CompletableFuture，第一个 CompletableFuture 根据证券名称查询证券代码，第二个 CompletableFuture 根据证券代码查询证券价格
   1. `thenApplyAsync()`用于串行化另一个 CompletableFuture
3. 多个 CompletableFuture 还可以**并行执行**
   1. `anyOf()` 可以实现“任意个 CompletableFuture 只要一个成功”
   2. `allOf()` 可以实现“所有 CompletableFuture 都必须成功”
4. 最后我们注意 CompletableFuture 的命名规则：`xxx()`表示该方法将继续在已有的线程中执行；`xxxAsync()`表示将异步在线程池中执行。

```java
// 类
@Test
public void example2() throws InterruptedException {
    // 创建异步执行任务
    CompletableFuture<Double> cf = CompletableFuture.supplyAsync(this::fetchPrice);
    // 如果执行成功
    cf.thenAccept(result -> {
        System.out.println(result);
    });
    // 如果执行失败
    cf.exceptionally(e -> {
        e.printStackTrace();
        System.out.println("11111111");
        return null;
    });
    Thread.sleep(2000);

}

public Double fetchPrice() {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {

    }
    if (Math.random() < 0.8) {
        throw new RuntimeException("fetch price failed !");
    }
    return 5 + Math.random() * 20;
}
```

# ForkJoin 大任务拆分为多个并行任务

Java 7 开始引入了一种新的 Fork/Join 线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。

我们举个例子：如果要计算一个超大数组的和，

1. 最简单的做法是用一个循环在一个线程内完成
2. 数组拆分为两个数组,并行计算两个数组的值,然后再相加
3. 如果拆成两部分还是很大，我们还可以继续拆，用 4 个线程并行执行

Fork/Join 任务的原理：**判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算**。这个过程可以反复“裂变”成一系列小任务。

1. 任务类必须继承自 `RecursiveTask` 或 `RecursiveAction`
2. 原理: 递归创建线程进行计算
3. 在 `compute()` 方法里
   1. 确定递归结束条件
   2. 定义子任务,及新建任务类对象
   3. `invokeAll() ` 并行计算子任务
   4. `join()`获得子任务的结果
   5. 汇总子任务结果,返回最后结果

```java
@Test
public void exampleForkJoin() {
    long[] array = new long[1000000000];
    long expectedSum = 0;
    Random random = new Random(0);
    for (int i = 0; i < array.length; i++) {
        array[i] = random.nextInt(10000);
    }
    long startTime1 = System.currentTimeMillis();
    for (int i = 0; i < array.length; i++) {
        expectedSum += array[i];
    }
    long endTime1 = System.currentTimeMillis();
    System.out.println("sum:" + expectedSum + ",time=" + (endTime1 - startTime1) + "ms");
    // fork/join
    ForkJoinTask<Long> forkJoinTask = new SumTask(array, 0, array.length);
    long startTime2 = System.currentTimeMillis();
    Long invoke = ForkJoinPool.commonPool().invoke(forkJoinTask);
    long endTime2 = System.currentTimeMillis();
    System.out.println("fork/join sum:" + invoke + ",time=" + (endTime2 - startTime2) + "ms");

}
class SumTask extends RecursiveTask<Long> {
    static final int THRESHOLD = 25000000;
    long[] array;
    int start;
    int end;

    public SumTask(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            // 如果任务足够小,直接计算
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += this.array[i];
            }
            return sum;
        }
        int middle = (end + start) / 2;
        //System.out.println(String.format("split %d-%d ==> %d-%d,%d-%d", start, end, start, middle, middle, end));
        SumTask sumTask1 = new SumTask(this.array, start, middle);
        SumTask sumTask2 = new SumTask(this.array, middle, end);
        invokeAll(sumTask1, sumTask2);
        Long subResult1 = sumTask1.join();
        Long subResult2 = sumTask2.join();
        Long result = subResult1 + subResult2;
        //System.out.printf("%d=%d+%d\n", result, subResult1, subResult2);
        // 汇总结果:
        return result;
    }
}
```
