# 注解

注释会被编译器直接忽略，注解则可以被编译器打包进入 class 文件，因此，注解是一种用作标注的“元数据”。

1. 开始版本: Java 5;
2. 注解: 代码里的特殊标记，这些标记可以在编译、类加载和运行时被读取，并执行相应的处理;
3. 以 `@` 符号开头;
4. 本质: 接口
5. 5 个基本注解 (Java 8 )
6. 6 个元注解 (Java 8 )
7. 注解定义后也是一种 class，所有的注解都继承自`java.lang.annotation.Annotation`

注解常见的作用有以下几种：

- 生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有 `@see`、`@param` 和 `@return` 等；
- 跟踪代码依赖性，实现替代配置文件功能。比较常见的是 Spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；
- 在编译时进行格式检查。如把 `@Override` 注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。

# 基本注解

```java
// 指定方法重写的，只能修饰方法并且只能用于方法重写，它可以强制一个子类必须重写父类方法或者实现接口的方法。
@Override
// 可以用来注解类、接口、成员方法和成员变量等，用于表示某个元素（类、方法等）已过时。当其他程序使用已过时的元素时，编译器将会给出警告。
/*
Java 9 为 @Deprecated 注解增加了以下两个属性：
forRemoval：该 boolean 类型的属性指定该 API 在将来是否会被删除。
since：该 String 类型的属性指定该 API 从哪个版本被标记为过时。
*/
@Deprecated
// 指示被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素
@SuppressWarnings
// 注解抑制编译器警告 相当于@SuppressWarnings("unchecked")
@SafeVarargs
// 只是告诉编译器检查这个接口，保证该接口只能包含一个抽象方法，否则就会编译出错。Lambda
@FunctionalInterface
```

# 元注解

元注解是负责对其它注解进行说明的注解，自定义注解时可以使用元注解。

Java 5 定义了 4 个注解，分别是 `@Documented`、`@Target`、`@Retention` 和 `@Inherited`。

Java 8 又增加了 `@Repeatable` 和 `@Native` 两个注解。

这些注解都可以在 `java.lang.annotation` 包中找到。

```java
/*
是一个标记注解，没有成员变量。用 @Documented 注解修饰的注解类会被 JavaDoc 工具提取成文档。默认情况下，JavaDoc 是不包括注解的，但如果声明注解时指定了 @Documented，就会被 JavaDoc 之类的工具处理，所以注解类型信息就会被包括在生成的帮助文档中。
*/
@Documented
/**
注解用来指定一个注解的使用范围，即被 @Target 修饰的注解可以用在什么地方。@Target 注解有一个成员变量（value）用来设置适用目标，value 是 `java.lang.annotation.ElementType` 枚举类型的数组

  类或接口：ElementType.TYPE；
  字段：ElementType.FIELD；
  方法：ElementType.METHOD；
  构造方法：ElementType.CONSTRUCTOR；
  方法参数：ElementType.PARAMETER。
*/
@Target
/**
用于描述注解的生命周期，也就是该注解被保留的时间长短。@Retention 注解中的成员变量（value）用来设置保留策略，value 是 `java.lang.annotation.RetentionPolicy` 枚举类型，RetentionPolicy 有 3 个枚举常量，如下所示。
  - SOURCE ：在源文件中有效（即源文件保留）
  - CLASS ：在 class 文件中有效（即 class 保留） //默认
  - RUNTIME ：在运行时有效（即运行时保留）
*/
@Retention
/**
是一个标记注解，用来指定该注解可以被继承。使用 @Inherited 注解的 Class 类，表示这个注解可以被用于该 Class 类的子类。就是说如果某个类使用了被 @Inherited 修饰的注解，则其子类将自动具有该注解。
 */
@Inherited
/**
注解是 Java 8 新增加的，它允许在相同的程序元素中重复注解，在需要对同一种注解多次使用时，往往需要借助 @Repeatable 注解。
 */
@Repeatable
/**
注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。
 */
@Native
```

# 自定义注解

1. `@interface` 定义
2. 元注解修饰,一般是 `@Target` `@Retention`
3. 定义属性:
   1. 其实是接口方法,返回值为 所有基本类型,String,枚举,以及以上类型的数组
   2. 配置参数必须是**常量**
   3. 默认值 `default`
   4. `value` 的配置参数,使用时可以只写常量 @xx(1)

```java
@Target({ElementType.TYPE}) // 元注解: 标明该注解可以用在哪里: 类\方法\属性\参数\构造方法\接口
@Retention(RetentionPolicy.RUNTIME)
public @interface DefineAnnotation {
    int type() default 0;

    String level() default "info";

    String value() default "";
}

```

# 注解的使用

通过反射获取注解，并依据注解设置的值对注解对象进行操作

```java
class.isAnnotationPresent(annotation.class) // 类上是否存在该注解
field.isAnnotationPresent(annotation.class) // 字段上是否存在该注解
method.isAnnotationPresent(annotation.class) // 方法上是否存在该注解
constructor.isAnnotationPresent(annotation.class) // 构造方法上是否存在该注解

// 获取注解,如果Annotation不存在，将返回null
Class.getAnnotation(Class)
Field.getAnnotation(Class)
Method.getAnnotation(Class)
Constructor.getAnnotation(Class)

//读取方法参数的Annotation
public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {}
// 获取Method实例:
Method m = ...
// 获取所有参数的Annotation:
Annotation[][] annos = m.getParameterAnnotations();
// 第一个参数（索引为0）的所有Annotation:
Annotation[] annosOfName = annos[0];
for (Annotation anno : annosOfName) {
    if (anno instanceof Range) { // @Range注解
        Range r = (Range) anno;
    }
    if (anno instanceof NotNull) { // @NotNull注解
        NotNull n = (NotNull) anno;
    }
}
```

## 重复注解

Java 8 支持了重复注解。在 Java 8 之前想实现重复注解，需要用一些方法来绕过限制。

## 类型注解

Java 8 之前注解只能用在声明中，在 Java 8 中，注解可以使用在 任何地方。
