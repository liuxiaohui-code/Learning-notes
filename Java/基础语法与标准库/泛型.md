# 泛型

​ 泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定 义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

- 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前。
- 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
- 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
- 泛型方法体的声明和其他方法一样。注意**类型参数只能代表引用型类型，不能是原始类型**（像 int、double、char 等）。

java 中泛型常用标记符：

- E - Element (在集合中使用，因为集合中存放的是元素)
- T - Type（Java 类）
- K - Key（键）
- V - Value（值）
- N - Number（数值类型）
- ？ - 表示不确定的 java 类型

限制:

1. Java 使用擦拭法实现泛型，导致了：编译器把类型`<T>`视为 Object；编译器根据`<T>`实现安全的强制转型。
2. `<T>`不能是基本类型，例如 int，因为实际类型是 Object，Object 类型无法持有基本类型
3. 无法取得带泛型的 `Class`
4. 无法判断带泛型的 `Class`
5. 一个类可以继承自一个泛型类,在继承了泛型类型的情况下，子类可以获取父类的泛型类型。但是比较复杂

```java
Type genericSuperclass = GenericType.class.getGenericSuperclass();
if (genericSuperclass instanceof ParameterizedType) {
    ParameterizedType pt = (ParameterizedType) genericSuperclass;
    Type[] atas = pt.getActualTypeArguments(); // 可能有多个
    Class<?> ata = (Class<?>) atas[0];
    System.out.println(ata);
}
```

因为 Java 引入了泛型，所以，只用 Class 来标识类型已经不够了

```yaml
Type:
  - Class
  - ParameterizedType # 参数化类型
  - GenericArrayType # 数组类型，其组件类型是参数化类型或类型变量
  - WildcardType # 表示一个通配符型表达，如 ? ， ? extends Number ，或 ? super Integer 。
```

## 泛型使用

泛型类

```java
public class GenericType<T> {
    public T name;

    public static <T> void genericMethod(T x) {
        System.out.println(x);
    }

    public static void main(String[] args) {
        GenericType<String> demo = new GenericType<>();
        demo.name = "name";
        System.out.println(demo.name);

        GenericType.<String>genericMethod("含泛型的静态方法");
    }
}

```

## 泛型限制类型

何时使用 `extends` ，何时使用 super？为了便于记忆，我们可以用 PECS 原则：Producer Extends Consumer Super。

即：如果需要返回 T，它是生产者（Producer），要使用 extends 通配符；如果需要写入 T，它是消费者（Consumer），要使用 super 通配符。

```java
<? extends Parent> 指定了泛型类型的上届
<? super Child> 指定了泛型类型的下届
<?> 指定了没有限制的泛型类型,<?>通配符有一个独特的特点，就是：Pair<?>是所有Pair<T>的超类：
```
