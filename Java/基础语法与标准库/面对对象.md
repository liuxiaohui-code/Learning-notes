# 面对对象

## 概念

面向对象思想从**概念**上讲分为以下三种：OOA、OOD、OOP

- `OOA` ：面向对象分析（Object Oriented Analysis）
- `OOD` ：面向对象设计（Object Oriented Design）
- `OOP` ：面向对象程序（Object Oriented Programming

三大**特征**：

- `封装性` ：所有的内容对外部不可见 private 与 getter setter
- `继承性` ：将其他的功能继承下来继续发展 extends
- `多态性` ：方法的重载本身就是一个多态性的体现 interface implements

类与对象：

​ 类表示一个共性的产物，是一个综合的特征，而对象，是一个个性的产物，是一个个体的特征。 （类似生活中的图纸与实物的概念。） 类必须通过对象才可以使用，对象的所有操作都在类中定义。 类由属性和方法组成：

​ · 属性：就相当于人的一个个的特征

​ · 方法：就相当于人的一个个的行为，例如：说话、吃饭、唱歌、睡觉

this：

​ · 调用类中的属性

​ · 调用类中的方法或构造方法

​ · 表示当前对象

## 创建

### 类定义

```java
// <类名>.java  文件名与类名保持一致，一个文件一个类
<访问控制> class <类名> { //类名使用大驼峰

	//构造函数
  <类名>(参数列表){}  //无返回值

	//类属性，使用： <类名>.<属性名>
  <访问控制> static <数据类型> <属性名>;

  //类方法，使用： <类名>.<方法名>();
  <访问控制> static <返回值类型> <方法名> (参数列表){}

  //成员属性，使用： <对象名>.<属性名>
  <访问控制> <数据类型> <属性名>;

  //成员方法，使用： <对象名>.<方法名>();
  <访问控制> <返回值类型> <方法名> (参数列表){}
}

public class Person {
  // 属性
  public String name;
  public int age;
  // 构造方法
  Person(){}
  // 成员方法
  public void func(){}
  // 静态代码块
  static {}
  // 构造代码块
  {}
  // 类方法
  public static void func1(){}

}
```

当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则。

- 一个源文件中只能有一个 `public` 类
- 一个源文件可以有多个非 `public` 类
- 源文件的名称应该和 `public` 类的类名保持一致。例如：源文件中 `public` 类的类名是 `Employee` ，那么源文件应该命名为 `Employee.java`。
- 如果一个类定义在某个包中，那么 `package` 语句应该在源文件的首行。
- 如果源文件包含 `import` 语句，那么应该放在 `package` 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。
- import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。

### 对象创建

```java
Person p = new Person();
```

### 代码块

**普通代码块**
在执行的流程中 出现的 代码块， 我们称其为普通代码块。
**构造代码块**
在类中的成员代码块， 我们称其为构造代码块， 在每次对象创建时执行， 执行在构造方法之前。
**静态代码块**
在类中使用 static 修饰的成员代码块， 我们称其为静态代码块， 在类加载时执行。 每次程序启动到关闭 ，只会执行一次的代码块。
**同步代码块**

构造方法 与 构造代码块 以及 静态代码块的执行顺序：**静态代码块 --> 构造代码块 --> 构造方法**

### 属性

**成员属性**
**静态属性**
用 `static` 修饰的字段，称为静态字段：实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。使用`类名.静态字段`访问;

### 访问控制

Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

- **private** : 在同一类内可见。使用对象：变量、方法。 **同类**
- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。**同类、同包**
- **protected** : 作用于继承关系。定义为 protected 的字段和方法可以被子类访问，以及子类的子类。使用对象：变量、方法。 **子类**；
- **public** : 对所有类可见。使用对象：类、接口、变量、方法

## 方法

### 可变参数

一个方法中定义完了参数，则在调用的时候必须传入与其一一对应的参数，但是在 JDK 1.5 之后提供了新的
功能，可以根据需要自动传入任意个数的参数。
语法：

```java
返回值类型 方法名称(数据类型 …参数名称){
//参数在方法内部 ， 以数组的形式来接收
}
```

注意：
可变参数只能出现在参数列表的最后。

### 构造方法

作用：用于对象初始化。
执行时机：在创建对象时,自动调用
特点:

1. 所有的 Java 类中都会至少存在一个构造方法
2. 如果一个类中没有明确的编写构造方法, 则编译器会自动生成一个无参的构造方法, 构造方法中没有任何的代码！
3. 如果自行编写了任意一个构造器, 则编译器不会再自动生成无参的构造方法
4. **子类的构造方法在被调用时,会默认调用父类的无参构造函数;**

```java
public class Person {
  public Person(){
    // 子类构造函数第一行默认调用了父类的构造函数
    super();
  }
}
```

### 静态方法(类方法)

静态方法属于 class 而不属于实例，因此，**静态方法内部，无法访问 this 变量，也无法访问实例字段，它只能访问静态字段**。通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。

## 封装

通过 private 关键字控制成员属性和方法,只用通过特定的方法才能访问这些属性;
常用的操作:

```java
public class Person{
  private String name;
  public void setName(String name){
    this.name = name;
  }
  public String getName(){
    return name;
  }
}
```

## 继承

特点：

1. 单继承
2. 子类拥有父类的 `public`,`protected` 方法和属性
3. 子类可以**重写**父类方法
4. 通过 `this` 关键字调用成员方法和属性,常用于成员方法的参数与成员属性名冲突;
5. 通过 `super` 访问父类的方法和属性,包括被子类重写的方法和属性;
6. 通过 `final` 修饰类和方法,防止子类继承和重写;

```java
class 类名 extends 父类 {
  类名(){
    //子类的构造方法第一行默认调用了 super()
    super()
  }
}
class Person{}
class Student extends Person{}
Person p = new Person();
Student s = new Student();
// 向上转型
Person p = new Student();
// 向下转型
Person p1 = new Student(); // upcasting, ok
Person p2 = new Person();
Student s1 = (Student) p1; // ok
Student s2 = (Student) p2; // runtime error! ClassCastException!
// 为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型：
Person p = new Student();
if (p instanceof Student) {
    // 只有判断成功才会向下转型:
    Student s = (Student) p; // 一定会成功
}
```

## 多态

多态：就是对象的多种表现形式，（多种体现形态）
对象的多态性，从概念上非常好理解，在类中有子类和父类之分，子类就是父类的一种形态 ，对象多态性
就从此而来。
ps: 方法的重载 和 重写 也是多态的一种， 不过是方法的多态（相同方法名的多种形态）。
重载： 一个类中方法的多态性体现
重写： 子父类中方法的多态性体现。

### 重载

方法的重载 ,可以让我们在不同的需求下, 通过传递不同的参数调用方法来完成具体的功能。

1. **方法名称**相同, **参数类型**或**参数个数**不同
2. **方法的重载与返回值无关!**

### 重写

1. 重写是方法的重写，与属性无关
2. 前提：继承，子类重写父类的方法
3. 返回值、方法名、参数表相同
4. 修饰符：范围可以扩大，但不可以缩小 `public` > `protected` >`default` > `private`
5. `@Override`

需要重写的原因：

1. 父类的功能子类不需要，或者不一定满足

### final

继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为 final。

1. 标记方法: **用 final 修饰的方法不能被子类重写**
2. 标记类: **用 final 修饰的类不能被继承**
3. 标记属性:**在初始化后不能被修改**,可以在构造方法中初始化 final 字段

## 抽象类 abstract

抽象类必须使用`abstract class`声明,**一个抽象类中可以没有抽象方法,但是抽象方法必须写在抽象类或者接口中。**
格式：

```java
abstract class 类名{ // 抽象类
  public abstract void 方法名() ; // 抽象方法，只声明而未实现
}
```

**在抽象类的使用中有几个原则：**

· 抽象类本身是不能直接进行实例化操作的，即：不能直接使用关键字 new 完成。

· 一个抽象类必须被子类所继承，被继承的子类（如果不是抽象类）则必须覆写(重写)抽象类中的全部抽象方法。

**1、 抽象类能否使用 final 声明？**

​ 不能，因为 final 属修饰的类是不能有子类的 ， 而抽象类必须有子类才有意义，所以不能。

**2、 抽象类能否有构造方法？**

```
能有构造方法，而且子类对象实例化的时候的流程与普通类的继承是一样的，都是要先调用父类中的构造方法（默认是无参的），之后再调用子类自己的构造方法。
```

**抽象类与普通类的区别：**

```
1、抽象类必须用public或procted 修饰(如果为private修饰，那么子类则无法继承，也就无法实现其 抽象方法）。默认缺省为 public

2、抽象类不可以使用new关键字创建对象， 但是在子类创建对象时， 抽象父类也会被JVM实例化。

3、如果一个子类继承抽象类，那么必须实现其所有的抽象方法。如果有未实现的抽象方法，那么子类也必须定义为 abstract类
```

## 内部类

在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。 广泛意义上的内部类一般来说包括这四种：

​ 1、成员内部类

​ 2、局部内部类

​ 3、匿名内部类 （终点）

​ 4、静态内部类

### 成员内部类

```java
成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：
class Outer {
	private double x = 0;
	public Outer(double x) {
		this.x = x;
	}
	class Inner { //内部类
		public void say() {
			System.out.println("x="+x);
		}
	}
}
特点： 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。
不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：
		外部类.this.成员变量
		外部类.this.成员方法
```

### 局部内部类

```
	局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
	注意:局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。
```

### 匿名内部类

```java
匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：
new 父类构造器（参数列表）|实现接口（）
{
//匿名内部类的类体部分
}
在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。

在使用匿名内部类的过程中，我们需要注意如下几点：
1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能
继承一个类或者实现一个接口。
2、匿名内部类中是不能定义构造函数的。
3、匿名内部类中不能存在任何的静态成员变量和静态方法。
4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。
5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
6、只能访问final型的局部变量
```

### 静态内部类

```
静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。
静态内部类是不需要依赖于外部类对象的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法.
```

## 包

我们使用 `package` 来解决名字冲突。

Java 定义了一种名字空间，称之为包： `package` 。一个类总是属于某个包，类名（比如 Person）只是一个简写，真正的完整类名是`包名.类名`。在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。

包可以是多层结构，用`.`隔开。例如：`java.util`。

要特别注意：**包没有父子关系**。java.util 和 java.util.zip 是不同的包，两者没有任何继承关系。

**没有定义包名的 class，它使用的是默认包**，非常容易引起名字冲突，因此，不推荐不写包名的做法。

我们还需要按照包结构把上面的 Java 文件组织起来。假设以 package_sample 作为根目录，src 作为源码目录，那么所有文件结构就是：

```
package_sample
└─ src
    ├─ hong
    │  └─ Person.java
    │  ming
    │  └─ Person.java
    └─ mr
       └─ jun
          └─ Arrays.java

即所有Java文件对应的目录层次要和包的层次一致。
```

**编译**: `javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java`

使用其他包的方式:

1. 直接写完整类名 `mr.jun.Arrays arrays = new mr.jun.Arrays();`
2. `import`: `import mr.jun.Arrays; Arrays arrays = new Arrays();`;可以使用`*`，表示把这个包下面的所有 class 都导入进来
3. `import static`,可以导入一个类的静态字段和静态方法;`import static java.lang.System.*;out.println("Hello, world!");`

Java 编译器最终编译出的`.class` 文件只使用完整类名，因此，在代码中，当编译器遇到一个 class 名称时：

1. 如果是`完整类名`，就直接根据完整类名查找这个 class；
2. 如果是`简单类名`，按下面的顺序依次查找：
   1. 查找当前 `package` 是否存在这个 class；
   2. 查找 `import` 的包是否包含这个 class；
   3. 查找 `java.lang` 包是否包含这个 class。
      如果按照上面的规则还无法确定类名，则编译报错。

编写 class 的时候，编译器会自动帮我们做两个 import 动作：

1. 默认自动 import 当前 package 的其他 class；
2. 默认自动 import java.lang.\*。

## classpath 和 jar

classpath 是 JVM 用到的一个环境变量，它用来指示 JVM 如何搜索 class。
因为 Java 是编译型语言，源码文件是.java，而编译后的.class 文件才是真正可以被 JVM 执行的字节码。因此，JVM 需要知道，如果要加载一个 abc.xyz.Hello 的类，应该去哪搜索对应的 Hello.class 文件。
现在我们假设 classpath 是`.;C:\work\project1\bin;C:\shared`，当 JVM 在加载 `abc.xyz.Hello` 这个类时，会依次查找：

1. `<当前目录>\abc\xyz\Hello.class`
2. `C:\work\project1\bin\abc\xyz\Hello.class`
3. `C:\shared\abc\xyz\Hello.class`

classpath 的设定方法有两种：

1. 在系统环境变量中设置 classpath 环境变量，不推荐；
2. 在启动 JVM 时设置 classpath 变量，推荐。
   1. `java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello`;简写:`java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello`
   2. `java abc.xyz.Hello` 默认 classpath 为`.`即当前目录;

如果有很多`.class`文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。`jar`包就是用来干这个事的，它**可以把 package 组织的目录层级，以及各个目录下的所有文件（包括.class 文件和其他文件）都打成一个 jar 文件**，这样一来，无论是备份，还是发给客户，就简单多了。

jar 包实际上就是一个`zip`格式的压缩文件，而 jar 包相当于目录。如果我们要执行一个 jar 包的 class，就可以把 jar 包放到 classpath 中：`java -cp ./hello.jar abc.xyz.Hello`

制作 jar 包:将所有 class 文件添加到一个 zip 压缩文件,然后修改后缀名为`.jar`

jar 包还可以包含一个特殊的`/META-INF/MANIFEST.MF`文件，MANIFEST.MF 是纯文本，可以指定 `Main-Class` 和其它信息。JVM 会自动读取这个 MANIFEST.MF 文件，如果存在 Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令：`java -jar hello.jar`

jar 包还可以包含其它 jar 包，这个时候，就需要**在 MANIFEST.MF 文件里配置 classpath**了。

在大型项目中，不可能手动编写 MANIFEST.MF 文件，再手动创建 zip 包。Java 社区提供了大量的开源构建工具，例如 Maven，可以非常方便地创建 jar 包。
