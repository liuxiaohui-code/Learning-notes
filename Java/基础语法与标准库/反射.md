# 反射

反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。

1.  Class newInstance()
2.  类加载机制
3.  Method invoke(user3,"xxx")
4.  Field set(xx,"xx")
5.  Construct
    1. newInstance()
    2. 获取的时候需要，传递参数的 Class 类型
6.  破坏私有关键字
    1. setAccessible(true)
7.  性能分析 正常>检测关闭的反射>默认的反射
8.  反射获取注解、泛型

**编译期**是指把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。

**运行期**是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。

**Java 反射机制**是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。

Java 反射机制主要提供了以下功能，这些功能都位于`java.lang.reflect`包。

- 在运行时判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法。
- 在运行时调用任意一个对象的方法。
- 生成动态代理。

要想知道一个类的属性和方法，必须先获取到该类的字节码文件对象。获取类的信息时，使用的就是 Class 类中的方法。所以先要获取到每一个字节码文件（.class）对应的 Class 类型的对象.

1. `class`由 JVM 在执行过程中动态加载的。JVM 在第一次读取到一种 class 类型时，将其加载进内存
2. 每加载一种 `class` ，JVM 就为其创建一个 `Class` 类型的实例，并关联起来
3. 一个 `Class` 实例包含了该 `class` 的所有完整信息
4. 通过 `Class` 实例获取 `class` 信息的方法称为**反射（Reflection）**

众所周知，所有 Java 类均继承了 Object 类，在 Object 类中定义了一个 getClass() 方法，该方法返回同一个类型为 Class 的对象。例如，下面的示例代码：
`Class labelCls = label1.getClass(); // label1为 JLabel 类的对象`

# JVM 动态加载 class

JVM 在执行 Java 程序的时候，并**不是一次性把所有用到的 class 全部加载到内存，而是第一次需要用到 class 时才加载**。

```java
/*
Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下
*/

// Commons Logging优先使用Log4j:
LogFactory factory = null;
if (isClassPresent("org.apache.logging.log4j.Logger")) {
    factory = createLog4j();
} else {
    factory = createJdkLog();
}
boolean isClassPresent(String name) {
    try {
        Class.forName(name);
        return true;
    } catch (Exception e) {
        return false;
    }
}

```

# 获取类实例

1. 获取类实例
   1. 通过静态属性 `Object.class`
   2. 通过继承的 Object 类方法`object.getClass()`
   3. 通过类的全限定名`Class.forName("全限定名称")`
2. 类实例唯一,可以使用`==`比较
3. 在 Class 类可以获取类的基本信息
   1. 类名
   2. 包名
   3. 访问权限
   4. ......

```java
package com.lxh.reflectDemo;

public class ClassHandle {
    public static void main(String[] args) throws ClassNotFoundException {
        // 1. 静态属性
        Class class1 = ClassHandle.class;
        // 2. Object 类的成员方法 getClass()
        Class class2 = new ClassHandle().getClass();
        // 3. 类全限定名
        Class class3 = Class.forName("com.lxh.reflectDemo.ClassHandle");
        System.out.println(class1);
        System.out.println(class2);
        System.out.println(class3);
        // 可以用`==`比较两个 Class 实例
        System.out.println("class1 == class2:" + (class1 == class2) + "\tclass1 == class3:" + (class1 == class3));
        /*
        class com.lxh.reflectDemo.ClassHandle
        class com.lxh.reflectDemo.ClassHandle
        class com.lxh.reflectDemo.ClassHandle
        class1 == class2:true	class1 == class3:true
         */
    }
}

```

Class 实例在 **JVM 中是唯一的**，所以，上述方法获取的 Class 实例是同一个实例。**可以用`==`比较两个 Class 实例**

注意到**数组**（例如`String[]`）也是一种 Class，而且不同于 String.class，它的类名是`[Ljava.lang.String`。

此外，JVM 为每一种**基本类型**如 int 也创建了 Class，通过`int.class`访问。

# 创建类对象

```java
// Class 类
// 创建实例
newInstance();// 局限是：只能调用public的无参数构造方法
```

```java
public static void main(String[] args) {
    // 1. 获取类实例
    Class<Demo> demoClass = Demo.class;
    // 2.
    Demo demo;
    try {
        demo = demoClass.newInstance();
        System.out.println(demo); // Demo{name='null', age=0}
    } catch (InstantiationException | IllegalAccessException e) {
        e.printStackTrace();
    }
}
```

# 字段

1. 获取 `Class` 实例
2. 通过 `Class` 实例获取字段 `Field` 实例

## 获取字段实例

```java
// Class 类
Field getField(name)：根据字段名获取某个public的field（包括父类）
Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）
Field[] getFields()：获取所有public的field（包括父类）
Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）
```

例子:

```java
Class<Demo> demoClass = Demo.class;
// 获取 public 属性
Field[] fields = demoClass.getFields(); // [public int com.lxh.reflectDemo.Demo.age]
System.out.println(Arrays.toString(fields));
// 获取所有声明的属性
Field[] declaredFields = demoClass.getDeclaredFields();
System.out.println(Arrays.toString(declaredFields));
/*[
private java.lang.String com.lxh.reflectDemo.Demo.name,
public int com.lxh.reflectDemo.Demo.age,
int com.lxh.reflectDemo.Demo.height,
protected int com.lxh.reflectDemo.Demo.weight
]*/
// 获取单个 public 属性
Field age = demoClass.getField("age");
System.out.println(age); //public int com.lxh.reflectDemo.Demo.age
// 获取单个 private 属性
Field name = demoClass.getDeclaredField("name");
System.out.println(name); // private java.lang.String com.lxh.reflectDemo.Demo.name
```

## 获取字段信息

```java
getName()：返回字段名称，例如，"name"；
getType()：返回字段类型，也是一个Class实例，例如，String.class；
getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。
```

例子:

```java
Field f = String.class.getDeclaredField("value");
f.getName(); // "value"
f.getType(); // class [B 表示byte[]类型
int m = f.getModifiers();
Modifier.isFinal(m); // true
Modifier.isPublic(m); // false
Modifier.isProtected(m); // false
Modifier.isPrivate(m); // true
Modifier.isStatic(m); // false
```

## 获取字段值

```java
field.get(Object) // 获取指定实例的指定字段的值
field.setAccessible(true)  // 允许访问 private
```

例子:

```java
        Demo xx = new Demo("xx", 1, 2, 3);
        Field age = Demo.class.getField("age");
        System.out.println("public age = " + age.get(xx));
        Field name = Demo.class.getDeclaredField("name");
        name.setAccessible(true); // 允许访问 private
        System.out.println("private name = " + name.get(xx));

// public age = 1
// private name = xx
```

如果使用反射可以获取 private 字段的值，那么类的封装还有什么意义？

1. 正常情况下，我们总是通过 p.name 来访问 Person 的 name 字段，编译器会根据 public、protected 和 private 决定是否允许访问字段，这样就达到了数据封装的目的。
2. 而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。
3. 此外，`setAccessible(true)`可能会失败。如果 JVM 运行期存在 `SecurityManager` ，那么它会根据规则进行检查，有可能阻止 `setAccessible(true)`。例如，某个 `SecurityManager` 可能不允许对 `java` 和 `javax` 开头的 `package` 的类调用 `setAccessible(true)`，这样可以保证 JVM 核心库的安全。

## 设置字段值

设置字段值是通过`Field.set(Object, Object)`实现的，其中第一个 Object 参数是指定的实例，第二个 Object 参数是待修改的值。

修改`非 public` 字段，需要首先调用 `setAccessible(true)`

# 成员方法

我们已经能通过 Class 实例获取所有 Field 对象，同样的，可以通过 Class 实例获取所有 `Method` 信息。Class 类提供了以下几个方法来获取 Method：

```Java
Method getMethod(name, Class…)：获取某个public的Method（包括父类）
Method getDeclaredMethod(name, Class…)：获取当前类的某个Method（不包括父类）
Method[] getMethods()：获取所有public的Method（包括父类）
Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）

** 方法的信息 **

getName()：返回方法名称，例如："getScore"；
getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；
getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；
getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。

Object invoke​(Object obj, Object... args)  // 调用 obj 对象的方法
method.invoke(null,Object... args) // 调用 obj 对象的静态方法
```

# 构造方法

`Constructor`

```Java
Class.newInstance() //局限是，它只能调用该类的public无参数构造方法。

// 调用Person的无参构造方法newInstance()
Person p = Person.class.newInstance();

通过Class实例获取 Constructor 的方法如下：

getConstructor(Class…)：获取某个public的Constructor；
getDeclaredConstructor(Class…)：获取某个Constructor；
getConstructors()：获取所有public的Constructor；
getDeclaredConstructors()：获取所有Constructor。
```

注意 `Constructor` **总是当前类定义的构造方法，和父类无关，因此不存在多态的问题**。
调用非 public 的 Constructor 时，必须首先通过 `setAccessible(true)`设置允许访问。**setAccessible(true)可能会失败**。

# 继承与实现关系

```java
class.getSuperclass();// 获取当前类的父类
class.getInterfaces();// 获取当前类实现的接口,只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型;如果一个类没有实现任何interface，那么getInterfaces()返回空数组。
// 对所有 interface 的 Class 调用 getSuperclass() 返回的是 null ，获取接口的父接口要用 getInterfaces()

//判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符
Object n = Integer.valueOf(123);
boolean isDouble = n instanceof Double; // false
boolean isInteger = n instanceof Integer; // true
boolean isNumber = n instanceof Number; // true
boolean isSerializable = n instanceof java.io.Serializable; // true

//如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()
// Integer i = ?
Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer
// Number n = ?
Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number
// Object o = ?
Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object
// Integer i = ?
Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer
```

# 动态代理(接口)

有没有可能不编写实现类，直接在运行期创建某个 `interface` 的实例呢？

这是可能的，因为 Java 标准库提供了一种动态代理（`Dynamic Proxy`）的机制：可以在运行期动态创建某个 `interface` 的实例。

1. 定义接口
2. 定义一个 `InvocationHandler` 实例，它负责实现接口的方法调用
3. 通过 `Proxy.newProxyInstance()`创建 `interface` 实例，它需要 3 个参数
   1. 使用的 `ClassLoader` ，通常就是接口类的 ClassLoader；
   2. 需要实现的`接口数组`，至少需要传入一个接口进去；
   3. 用来处理接口方法调用的 `InvocationHandler` 实例。
4. 将返回的 Object `强制转型`为接口。

动态代理实际上是 JDK 在运行期动态创建 class 字节码并加载的过程，它并没有什么黑魔法

正常接口的使用:

```java
// 接口
public interface Hello {
    void morning(String name);
}
// 实现类
public class HelloWorld implements Hello {
    public void morning(String name) {
        System.out.println("Good morning, " + name);
    }
}
// 创建接口实例
Hello hello = new HelloWorld();
hello.morning("Bob");
```

动态代理: 仍然先定义了接口 Hello，但是我们并不去编写实现类，而是直接通过 JDK 提供的一个 `Proxy.newProxyInstance()`创建了一个 Hello 接口对象。

```java
public class InterfaceProxy {
    public static void main(String[] args) {
        Hello hello = (Hello) Proxy.newProxyInstance(
                Hello.class.getClassLoader(), // 传入 Hello 接口的类加载器
                new Class[]{Hello.class}, // 传入要实现的接口
                new InvocationHandler() { // 实现方法
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println(method);
                        if (method.getName().equals("hello")) { // 实现接口方法 hello
                            System.out.println("hello , " + args[0]);
                        }
                        return null;
                    }
                }
        );
        hello.hello("interface proxy !");
    }
}

interface Hello {
    void hello(String obj);
}
```

# 内部类

```java
内部类	    getClasses()	        Class 型数组	          获取所有权限为 public 的内部类
            getDeclaredClasses()	Class 型数组	        获取所有内部类
内部类的声明类	getDeclaringClass()	Class 对象	        如果该类为内部类，则返回它的成员类，否则返回 null

```

# 注解

```java
class.getAnnotation() // 获取该类的注解
```

# java.lang.reflect 包

java.lang.reflect 包提供了反射中用到类，主要的类说明如下：

1. Constructor 类：提供类的构造方法信息。
2. Field 类：提供类或接口中成员变量信息。
3. Method 类：提供类或接口成员方法信息。
4. Array 类：提供了动态创建和访问 Java 数组的方法。
5. Modifier 类：提供类和成员访问修饰符信息。
