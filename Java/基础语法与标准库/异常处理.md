# 异常处理

异常是在程序中导致程序中断运行的一种指令流。

获知异常的方法:

1. 约定返回错误码,这种方式常见于底层 C 函数。
2. 在语言层面上提供一个异常处理机制,Java 异常类
3. `Throwable`
   1. `Exception` 运行时的错误，它可以被捕获并处理
      1. `RuntimeException` 运行时异常
         1. 0/1
         2. ClassNotFound
         3. NullPoint
         4. UnLownType
         5. 下标越界
         6. ...
      2. 非 RuntimeException
         1. IOException
         2. ReflectiveOperationException
      3. `printStackTrace()` 打印出方法的调用栈
   2. `Error`
      1. AWT 错误
      2. JVM 错误
         1. StackOverflowError 栈溢出
         2. OutOfMemoryError 内存溢出
         3. NoClassDefFoundError 无法加载某个 Class

# 捕获与处理

1. 在 Java 中，凡是可能抛出异常的语句，都可以用`try … catch`捕获。把可能发生异常的语句放在`try { … }`中，然后使用`catch`捕获对应的`Exception`及其子类。
2. JVM 在捕获到异常后，会从上到下匹配 `catch` 语句，匹配到某个 `catch` 后，执行 `catch` 代码块，然后不再继续匹配。**多个 catch 语句只有一个能被执行**。
3. 存在多个 `catch` 的时候，catch 的顺序非常重要：**子类必须写在前面**。
4. `finally` 总是最后执行;不是必须的，可写可不写;

```java
//如果要想对异常进行处理，则必须采用标准的处理格式，处理格式语法如下：
try{
// 有可能发生异常的代码段
}catch(异常类型1 对象名1){
// 异常的处理操作
}catch(异常类型2 对象名2){
// 异常的处理操作
}
//特殊的多异常捕获写法：
catch(异常类型1 | 异常类型2 对象名){
//表示此块用于处理异常类型1 和 异常类型2 的异常信息
}
...
/*
  多异常捕获的注意点：
		1、 捕获更粗的异常不能放在捕获更细的异常之前。
		2、 如果为了方便，则可以将所有的异常都使用Exception进行捕获。
*/
finally{
// 异常的统一出口，不管是否产生了异常，最终都要执行此段代码。
}

1、 一旦产生异常，则系统会自动产生一个异常类的实例化对象。
2、 那么，此时如果异常发生在try语句，则会自动找到匹配的catch语句执行，如果没有在try语句中，则会将异
常抛出.
3、 所有的catch根据方法的参数匹配异常类的实例化对象，如果匹配成功，则表示由此catch进行处理。
```

> 1. try-catch-finally 中哪个部分可以省略？
>
>    答： catch 和 finally 可以省略其中一个 ， catch 和 finally 不能同时省略 注意:格式上允许省略 catch 块, 但是发生异常时就不会捕获异常了,我们在开发中也不会这样去写代码
>
> 2. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
>
>    答：finally 中的代码会执行 详解： 执行流程：
>
>    1. 先计算返回值，并将返回值存储起来，等待返回
>
>    2. 执行 finally 代码块
>
>    3. 将之前存储的返回值，返回出去；
>
>       需注意：
>
>       1. 返回值是在 finally 运算之前就确定了，并且缓存了，不管 finally 对该值做任何的改变，返回的值都不会改变
>       2. finally 代码中不建议包含 return，因为程序会在上述的流程中提前退出，也就是说返回的值不是 try 或 catch 中的值
>       3. 如果在 try 或 catch 中停止了 JVM,则 finally 不会执行.例如停电- -, 或通过如下代码退出 JVM:System.exit(0)

# 抛出

1. 当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个`try … catch`被捕获为止
2. `throws` 用在方法上，用于抛出方法内部产生的异常给调用者
3. `throw` 在方法内部抛出异常
4. `finally` 抛出异常后，原来在 catch 中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为**被屏蔽的异常**（Suppressed Exception）。

```java
返回值 方法名称() throws Exception{
}
```

**throw** 人为制造一个异常

```java
throw关键字表示在程序中人为的抛出一个异常，因为从异常处理机制来看，所有的异常一旦产生之后，实际上抛出的就是一个异常类的实例化对象，那么此对象也可以由throw直接抛出。
代码： throw new Exception("抛着玩的。") ;
```

# 自定义异常类

- 编写一个类， 继承 Exception，并重写一参构造方法 即可完成自定义受检异常类型。
- 编写一个类， 继承 RuntimeExcepion，并重写一参构造方法 即可完成自定义运行时异常类型。

```java
class MyException extends Exception{ // 继承Exception，表示一个自定义异常类
	public MyException(String msg){
		super(msg) ; // 调用Exception中有一个参数的构造
	}
};

// 自定义异常可以做很多事情， 例如：
class MyException extends Exception{
	public MyException(String msg){
		super(msg) ;
		//在这里给维护人员发短信或邮件， 告知程序出现了BUG。
	}
};
```

# 使用断言

断言（Assertion）是一种调试程序的方式。

1. 在 Java 中，使用 `assert` 关键字来实现断言。
2. 如果计算结果为 false，则断言失败，抛出 `AssertionError`
3. 对于可恢复的程序错误，不应该使用断言。
4. JVM 开启断言:要执行 assert 语句，必须给 Java 虚拟机传递`-enableassertions`（可简写为`-ea`）参数启用断言。
   1. `$ java -ea Main.java`
   2. 还可以有选择地对特定地类启用断言，命令行参数是：`-ea:com.itranswarp.sample.Main`，表示只对`com.itranswarp.sample.Main`这个类启用断言。
   3. 对特定地包启用断言，命令行参数是：`-ea:com.itranswarp.sample…`（注意结尾有 3 个.），表示对 `com.itranswarp.sample` 这个包启动断言。
5. 实际开发中，很少使用断言。更好的方法是编写**单元测试**，

```java
// assert <断言条件>;
assert x >= 0;
// assert <断言条件>[:<可选的断言消息>];  断言失败的时候，AssertionError会带上消息x must >= 0，
assert x >= 0 : "x must >= 0";
```

# jdk logging

输出日志，而不是用 System.out.println()，有以下几个好处：

1. 可以**设置输出样式**，避免自己每次都写`"ERROR: " + var`；
2. 可以设置**输出级别**，禁止某些级别输出。例如，只输出错误日志；
3. 可以**被重定向到文件**，这样可以在程序运行结束后查看日志；
4. 可以**按包名控制日志级别**，只输出某些包打的日志；
5. 可以……总之就是好处很多啦。
6. Java 标准库内置了日志包 `java.util.logging`，我们可以直接用。

```java
Logger logger = Logger.getGlobal();
logger.info("信息");
logger.warning("警告");
logger.fine("忽略");
logger.severe("严重");

十月 11, 2022 3:16:46 下午 com.lxh.errorHandle.JdkLog main
信息: 信息
十月 11, 2022 3:16:46 下午 com.lxh.errorHandle.JdkLog main
警告: 警告
十月 11, 2022 3:16:46 下午 com.lxh.errorHandle.JdkLog main
严重: 严重
```

## 日志级别

JDK 的 Logging 定义了 7 个日志级别，从严重到普通：

- `SEVERE` 严重
- `WARNING` 警告
- `INFO` 信息 -- 默认
- `CONFIG` 配置
- `FINE` 好
- `FINER` 很好
- `FINEST` 最好

## 局限

1. Logging 系统在 JVM 启动时读取配置文件并完成初始化，一旦开始运行 main()方法，就无法修改配置；
2. 配置不太方便，需要在 JVM 启动时传递参数`-Djava.util.logging.config.file=<config-file-name>`

## commons logging

和 Java 标准库提供的日志不同，Commons Logging 是一个第三方日志库，它是由 Apache 创建的日志模块。

Commons Logging 的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin 自动搜索并使用 Log4j（Log4j 是另一个流行的日志系统），如果没有找到 Log4j，再使用 JDK Logging。

使用 Commons Logging 只需要和两个类打交道，并且只有两步：

1. 通过 LogFactory 获取 Log 类的实例
2. 使用 Log 实例的方法打日志
3. 编译 : `javac -cp commons-logging-1.2.jar Main.java`
4. 运行 : `java -cp .:commons-logging-1.2.jar Main`

```java
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class CommonsLog {
    static final Log log = LogFactory.getLog(CommonsLog.class);

    public static void main(String[] args) {
        log.info("process start ...");
        log.warn("process end ...");
    }
}

```

Commons Logging 定义了 6 个日志级别：

`FATAL`
`ERROR`
`WARNING`
`INFO` -- 默认
`DEBUG`
`TRACE`

## log4j

Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用 Log4j。
当我们使用 Log4j 输出一条日志时，Log4j 自动通过不同的 Appender 把同一条日志输出到不同的目的地。例如：

console：输出到屏幕；
file：输出到文件；
socket：通过网络输出到远程计算机；
jdbc：输出到数据库

在输出日志的过程中，通过 Filter 来过滤哪些 log 需要被输出，哪些 log 不需要被输出。

最后，通过 Layout 来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。

log4j2.xml 的文件放到 classpath

```xml
<!-- log4j2.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<Configuration>
    <Properties>
        <!-- 定义日志格式 -->
        <Property name="log.pattern">%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n</Property>
        <!-- 定义文件名变量 -->
        <Property name="file.err.filename">log/err.log</Property>
        <Property name="file.err.pattern">log/err.%i.log.gz</Property>
    </Properties>
    <!-- 定义Appender，即目的地 -->
    <Appenders>
        <!-- 定义输出到屏幕 -->
        <Console name="console" target="SYSTEM_OUT">
            <!-- 日志格式引用上面定义的log.pattern -->
            <PatternLayout pattern="${log.pattern}" />
        </Console>
        <!-- 定义输出到文件,文件名引用上面定义的file.err.filename -->
        <RollingFile name="err" bufferedIO="true" fileName="${file.err.filename}" filePattern="${file.err.pattern}">
            <PatternLayout pattern="${log.pattern}" />
            <Policies>
                <!-- 根据文件大小自动切割日志 -->
                <SizeBasedTriggeringPolicy size="1 MB" />
            </Policies>
            <!-- 保留最近10份 -->
            <DefaultRolloverStrategy max="10" />
        </RollingFile>
    </Appenders>
    <Loggers>
        <Root level="info">
            <!-- 对info级别的日志，输出到console -->
            <AppenderRef ref="console" level="info" />
            <!-- 对error级别的日志，输出到err，即上面定义的RollingFile -->
            <AppenderRef ref="err" level="error" />
        </Root>
    </Loggers>
</Configuration>
```

```xml
log4j-api-2.x.jar
log4j-core-2.x.jar
log4j-jcl-2.x.jar
commons-logging-1.2.jar
```

在开发阶段，始终使用 Commons Logging 接口来写入日志，并且开发阶段无需引入 Log4j。如果需要把日志写入文件，只需要把正确的配置文件和 Log4j 相关的 jar 包放入 classpath，就可以自动把日志切换成使用 Log4j 写入，无需修改任何代码。

## sif4j 和 logback

前面介绍了 Commons Logging 和 Log4j 这一对好基友，它们一个负责充当日志 API，一个负责实现日志底层，搭配使用非常便于开发。
其实 SLF4J 类似于 Commons Logging，也是一个日志接口，而 Logback 类似于 Log4j，是一个日志的实现。

```java
// SLF4J的日志接口
int score = 99;
p.setScore(score);
logger.info("Set score {} for Person {} ok.", score, p.getName());
```

如何使用 SLF4J？它的接口实际上和 Commons Logging 几乎一模一样

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
class Main {
    final Logger logger = LoggerFactory.getLogger(getClass());
}


slf4j-api-1.7.x.jar
logback-classic-1.2.x.jar
logback-core-1.2.x.jar
```

```xml
<!-- logback.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf-8</charset>
        </encoder>
        <file>log/output.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
            <fileNamePattern>log/output.log.%i</fileNamePattern>
        </rollingPolicy>
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <MaxFileSize>1MB</MaxFileSize>
        </triggeringPolicy>
    </appender>
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
</configuration>

```
