# 枚举

1. 定义的 `enum` 类型总是继承自 `java.lang.Enum`，且无法被继承；
2. 只能定义出 `enum` 的实例，而无法通过 `new` 操作符创建 `enum` 的实例；
3. 定义的每个实例都是引用类型的唯一实例；默认都被 `final、public, static` 修饰
4. 可以将 `enum` 类型用于 `switch` 语句。
5. 注意：枚举类的字段也可以是非 final 类型，即可以在运行期修改，但是不推荐这样做！


命名规范：
枚举名称，首字母大写，驼峰标识；其枚举值，全大写，下划线分割；
命名规范参考：java.lang.Character的UnicodeScript枚举示例；

定义枚举类时，如果只有枚举值，则最后一个枚举值后可以没有逗号或分号； 如果有自定义方法，则最后一个枚举值与后续代码之间要用分号隔开，不能使用逗号或空格；
5、枚举可以实现接口，代码参考：java.net.StandardProtocolFamily implements ProtocolFamily；

6、比较枚举时，要使用equal方法，不能使用==方法比较，否则在分布式环境下会出错；（enum的值是在运行期生成，在 cluster 环境下，每个虚拟机都会构造出一个同义的枚举对象。因此使用==方法比较时，其枚举值一定不相等，因为这不是同一个对象实例。



7、String字符串转换为枚举

有些时候（历史问题、旧的接口等），会传输String类型，而不是枚举类，

需要内部将String转换为枚举，方法如下（以上文中的颜色为例）：
```java
public static String getDescOfColor(String colorStr) {
  try {
    Color entry = Enum.valueOf(Color.class, colorStr);
    return entry.getDesc();
  } catch (Exception e) {
    return "未知颜色["+colorStr+"]";
  }
}
```
```java
// 关键字 eum
public enum Color {
  // 枚举成员 x,y,z,...;
  RED,BLUE,GREEN,BLACK;
}



// 编译器编译出的class大概就像这样
public final class Color extends Enum { // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() {}
}
```

优点:

1. enum 常量本身带有类型信息
2. 不可能引用到非枚举的值，因为无法通过编译
3. 不同类型的枚举不能互相比较或者赋值，因为类型不符。

使得编译器可以在编译期自动检查出所有可能的潜在错误。

## 比较

枚举类是引用类型,可以重重写`equals()`方法进行比较;另外,因为 enum 类型的每个常量在 JVM 中只有一个唯一实例，所以可以直接用`==`比较;

## 常用方法

```java
name() 返回常量名
String s = Weekday.SUN.name(); // "SUN"

toString()  默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。
// 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！

values()	以数组形式返回枚举类型的所有成员

valueOf()	将普通字符串（枚举成员的字符串形式）转换为枚举实例

compareTo()	比较两个枚举成员在定义时的顺序

ordinal()	返回定义的常量的顺序，从0开始计数 //要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段
int n = Weekday.MON.ordinal(); // 1
```

## 为枚举添加方法

```java
enum WeekDay {
  // 枚举的成员，必须先定义，而且使用分号结束
  Mon("Monday"),Tue("Tuesday"),Wed("Wednesday"),Thu("Thursday"),Fri("Friday"),Sat("Saturday"),Sun("Sunday");
  // 属性
  private final String day;
  // 构造函数
  private WeekDay(String day) {
    this.day = day;
  }
  //
  public static void printDay(int i) {
          switch(i) {
              case 1:
                  System.out.println(WeekDay.Mon);
                  break;
              case 2:
                  System.out.println(WeekDay.Tue);
                  break;
              case 3:
                  System.out.println(WeekDay.Wed);
                  break;
              case 4:
                  System.out.println(WeekDay.Thu);
                  break;
              case 5:
                  System.out.println(WeekDay.Fri);
                  break;
              case 6:
                  System.out.println(WeekDay.Sat);
                  break;
              case 7:
                  System.out.println(WeekDay.Sun);
                  break;
              default:
                  System.out.println("wrong number!");
          }
  }

  // 枚举方法
  public String getDay() {
    return day;
  }
  @Override
  public String toString() {
    return this.day ;
  }
}
```

## EnumMap

EnumMap 是专门为枚举类型量身定做的 Map 实现，HashMap 只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值，使得 EnumMap 的效率非常高。

## EnumSet

EnumSet 是枚举类型的高性能 Set 实现，它要求放入它的枚举常量必须属于同一枚举类型。

## 常用枚举工具类

```java
package com.epoint.shenhua.jsgcztbmis2.jiaoyisystem.service;

import java.util.EnumSet;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * 枚举通用接口
 *  
 * @author lxiaohui
 * @version 2023年12月7日
 */
public interface ICommonEnumHandler
{
    String getValue();

    /**
     * 通过枚举的value值获取枚举常量
     *  
     *  @param <E>
     *  @param value
     *  @param clazz
     *  @return
     */
    static <E extends Enum<E> & ICommonEnumHandler> E getEnmu(String value, Class<E> clazz) {
        EnumSet<E> all = EnumSet.allOf(clazz);
        return all.stream().filter(e -> value.equals(e.getValue())).findFirst().orElse(null);
    }
    /**
     * 打印枚举的所有值 [name1:value1,name2:value2,...]
     *  
     *  @param <E>
     *  @param clazz 枚举类型
     *  @return
     */
    static <E extends Enum<E> & ICommonEnumHandler> String print(Class<E> clazz) {
        EnumSet<E> all = EnumSet.allOf(clazz);
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("[");
        all.stream().forEach(e->{
            stringBuilder.append(e.name());
            stringBuilder.append(":");
            stringBuilder.append(e.getValue());
            stringBuilder.append(",");
        });
        stringBuilder.append("]");
        return stringBuilder.toString().replace(",]", "]");
    }
    /**
     * 将枚举值转换为map,value->name
     *  
     *  @param <E>
     *  @param clazz
     *  @return
     */
    static <E extends Enum<E> & ICommonEnumHandler> Map<String,String> toMap(Class<E> clazz) {
        return EnumSet.allOf(clazz).stream().collect(Collectors.toMap(n->n.getValue(),n->n.name())); 
    }
}

```
使用:

1. 实现接口 ICommonEnumHandler
2. 调用方法

```java
public enum Fruit implements ICommonEnumHandler{
  苹果("apple");
  private String value;
  Fruit(String value){
    this.value = value;
  }
  public String getValue(){
    return this.value;
  }
}
Fruit x = ICommonEnumHandler.getEnmu("apple",Fruit.class);
x.equals(Fruit.苹果); //true
```