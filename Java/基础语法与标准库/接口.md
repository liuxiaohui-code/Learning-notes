# 接口 interface

**接口比抽象类更抽象**如果一个类中的全部方法都是抽象方法，全部属性都是全局常量，那么此时就可以将这个类定义成一个接口。
特点:

1. 方法全是抽象方法,属性都是静态常量
2. 多继承
3. 多实现
4. jdk1.8 `default` 方法,实现类可以不必覆写 default 方法。

```java

interface X接口名称 extends A,B{
	[public static final] 全局常量 ;
	[public abstract] 抽象方法 ;
  default void func(int x){}
}
class XImpl implements X,A,B,C,D{
  @Override
}
```

**接口与抽象类的区别**

1、抽象类要被子类继承，接口要被类实现。
2、接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。
3、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
4、抽象类使用继承来使用，无法多继承。 接口使用实现来使用， 可以多实现
5、抽象类中可以包含 static 方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明静态方法）
6、接口不能有构造方法，但是抽象类可以有

## 函数式接口: 只有一个接口方法的接口

java 为我们提供了四个比较重要的函数式接口:

消费型接口 `Consumer<T>`: ` void accept(T t)`有参数，无返回值的抽象方法；
供给型接口 `Supplier <T>`: ` T get()` 无参有返回值的抽象方法；
断定型接口 `Predicate<T> `: `boolean test(T t)`:有参，但是返回值类型是固定的 boolean
函数型接口 `Function<T,R>`: ` R apply(T t)`有参有返回值的抽象方法；

## lambda 表达式 (jdk 8)

1. 函数式接口的匿名实现,可以使用 lambda 表达式;
2. lambda 表达式可以转换为匿名类
3. 写法 `(参数表)->{方法体}`
   1. `x->{}` 只有一个参数可以省略()
   2. `()->""` 方法体只有一个返回语句,可以省略{},return 和;号

```java
/**
只有一个接口方法
 */
@FunctionalInterface
interface Operation {
    int operation(int a, int b);
}

class Test {
    private int operate(int a, int b, Operation operation) {
        return operation.operation(a, b);
    }
}

Test test = new Test();

test.operate(1,2,(a,b)->a+b);
```

## 方法引用(jdk8)

通过方法引用，可以使用方法的名字来指向一个方法。使用一对冒号来引 `::` 用方法。

构造方法引用
使用方式：`Class::new`

静态方法引用
使用方式：`Class::staticMethod`

对象的实例方法引用
使用方式：`instance::method`

类的实例方法引用
使用方式：`Class::method`

作用: 指代一个实现函数式接口的匿名对象,要求除函数名可以不一致外,参数表和返回值类型要保持一致

```java
    @FunctionalInterface
    interface Operation {
        int operation(int a, int b);
    }
    @FunctionalInterface
    interface Operation2 {
        int operation(OperationFactory factory,int a, int b);
    }
    @FunctionalInterface
    interface Operation3 {
        OperationFactory operation();
    }
    static class OperationFactory{
        int add(int a,int b){
            return a+b;
        }
        //add, subtract, multiply and divide
        static int subtract(int a,int b){
            return a-b;
        }
        int multiply(int a,int b){
            return a*b;
        }
        int divide(int a,int b){
            return a/b;
        }

        @Override
        public String toString() {
            return "OperationFactory{}";
        }
    }
    @Test
    void methodReference(){
        // 对象的实例方法
        Operation operation1 = new OperationFactory()::add;
        System.out.println(operation1.operation(1,2));
        // 类的静态方法
        Operation operation2 = OperationFactory::subtract;
        System.out.println(operation2.operation(1,2));
        // 类的实例方法
        Operation2 operation3 = OperationFactory::multiply;
        System.out.println(operation3.operation(new OperationFactory(),2,2));
        // 类的构造方法
        Operation3 operation4 = OperationFactory::new;
        System.out.println(operation4.operation());
    }
```

## 默认方法和静态方法(jdk8)

```java
public interface TestInterface {
    String test();

    // 接口默认方法,类似于抽象类的非抽象方法
    default String defaultTest() {
        return "default";
    }
    // 接口静态方法
    static String staticTest() {
        return "static";
    }
}
```
## 私有方法(jdk9)
java 9 可以使用私有方法