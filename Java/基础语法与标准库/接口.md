# 接口 interface

**接口比抽象类更抽象**如果一个类中的全部方法都是抽象方法，全部属性都是全局常量，那么此时就可以将这个类定义成一个接口。
特点:

1. 方法全是抽象方法,属性都是静态常量
2. 多继承
3. 多实现
4. jdk1.8 `default` 方法,实现类可以不必覆写 default 方法。

```java

interface X接口名称 extends A,B{
	[public static final] 全局常量 ;
	[public abstract] 抽象方法 ;
  default void func(int x){}
}
class XImpl implements X,A,B,C,D{
  @Override
}
```

**接口与抽象类的区别**

1、抽象类要被子类继承，接口要被类实现。
2、接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。
3、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
4、抽象类使用继承来使用，无法多继承。 接口使用实现来使用， 可以多实现
5、抽象类中可以包含 static 方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明静态方法）
6、接口不能有构造方法，但是抽象类可以有

## lambda 表达式 (jdk 8)

1. 函数式接口的匿名实现,可以使用 lambda 表达式;
2. lambda 表达式可以转换为匿名类
3. 写法 `(参数表)->{方法体}`
   1. `x->{}` 只有一个参数可以省略()
   2. `()->""` 方法体只有一个返回语句,可以省略{},return 和;号

```java
/**
只有一个接口方法
 */
@FunctionalInterface
interface Operation {
    int operation(int a, int b);
}

class Test {
    private int operate(int a, int b, Operation operation) {
        return operation.operation(a, b);
    }
}

Test test = new Test();

test.operate(1,2,(a,b)->a+b);
```

## 方法引用(jdk8)

通过方法引用，可以使用方法的名字来指向一个方法。使用一对冒号来引 `::` 用方法。

构造方法引用
使用方式：`Class::new`

静态方法引用
使用方式：`Class::staticMethod`

对象的实例方法引用
使用方式：`instance::method`

类的实例方法引用
使用方式：`Class::method`

作用: 指代一个实现函数式接口的匿名对象,要求除函数名可以不一致外,参数表和返回值类型要保持一致

```java
@FunctionalInterface
interface Operation {
    int operation(int a, int b);
}
class x{
  int test(int a, int b){
    return a+b;
  }
  int testA(int a, int b,Operation o){
    return o(a,b);
  }
  @Test
  void testA(){
    testA(1,2,this::test); // 3
  }
}
```

## 默认方法和静态方法(jdk8)

```java
public interface TestInterface {
    String test();

    // 接口默认方法
    default String defaultTest() {
        return "default";
    }
    // 接口静态方法
    static String staticTest() {
        return "static";
    }
}
```
