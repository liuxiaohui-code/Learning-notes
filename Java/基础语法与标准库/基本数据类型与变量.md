# 数据类型与变量

## 内置类型

Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

### byte 1

- byte 数据类型是 8 位、有符号的，以二进制补码表示的整数；
- 最小值是 **-128（-2^7）**；
- 最大值是 **127（2^7-1）**；
- 默认值是 **0**；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
- 例子：byte a = 100，byte b = -50。

### short 2

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 **-32768（-2^15）**；
- 最大值是 **32767（2^15 - 1）**；
- Short 数据类型也可以像 byte 那样节省空间。一个 short 变量是 int 型变量所占空间的二分之一；
- 默认值是 **0**；
- 例子：short s = 1000，short r = -20000。

### int 4

- int 数据类型是 32 位、有符号的以二进制补码表示的整数；
- 最小值是 **-2,147,483,648（-2^31）**；
- 最大值是 **2,147,483,647（2^31 - 1）**；
- 一般地整型变量默认为 int 类型；
- 默认值是 **0** ；
- 例子：int a = 100000, int b = -200000。

### long 8

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；
- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 **0L**；
- 例子： **long a = 100000L**，**long b = -200000L**。
  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

### float 4

- float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 **0.0f**；
- 浮点数不能用来表示精确的值，如货币；
- 例子：float f1 = 234.5f。

### double 8

- double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；
- 浮点数的默认类型为 double 类型；
- double 类型同样不能表示精确的值，如货币；
- 默认值是 **0.0d**；

- 例子：

  ```
  double   d1  = 7D ;
  double   d2  = 7.;
  double   d3  =  8.0;
  double   d4  =  8.D;
  double   d5  =  12.9867;
  ```

  7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。

### boolean

- boolean 数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 **false**；
- 例子：boolean one = true。
- Java 语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要 1 bit，但是通常 JVM 内部会把 boolean 表示为 4 字节整数。

### char 2

- char 类型是一个单一的 16 位 Unicode 字符；
- 最小值是 **\u0000**（十进制等效值为 0）；
- 最大值是 **\uffff**（即为 65535）；
- char 数据类型可以储存任何字符；

```java
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013
// 注意是十六进制:直接用转义字符\u+Unicode编码来表示一个字符
char c3 = '\u0041'; // 'A'，因为十六进制0041 = 十进制65
char c4 = '\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013
```

因为 Java 在内存中总是使用`Unicode`表示字符，所以，一个英文字符和一个中文字符都用一个 char 类型表示，它们都占用两个字节。要显示一个字符的 Unicode 编码，只需将 char 类型直接赋值给 int 类型即可：

### 包装类

1. 基本类型的包装类
2. jdk1.5 自动装箱与拆箱
3. `Integer` `==`比较;为了节省内存，`Integer.valueOf()`对于较小的数`(<128)`，**始终返回相同的实例**，因此，`==`比较“恰好”为`true`，所以必须使用 `equals()`比较包装类
4. 创建包装类对象优先使用`Integer.valueOf()` 静态工厂的方式,而不是 `new` 操作符

在 Java 中有一个设计的原则“一切皆对象”，那么这样一来 Java 中的一些基本的数据类型，就完全不符合于 这种设计思想，因为 Java 中的八种基本数据类型并不是引用数据类型，所以 Java 中为了解决这样的问题， 引入了八种基本数据类型的包装类。

```
序号 基本数据类型 包装类
1 		int 			Integer
2 		char 			Character
3 		float 		Float
4 		double		Double
5 		boolean 	Boolean
6 		byte 			Byte
7 		short 		Short
8 		long 			Long
```

以上的八种包装类，可以将基本数据类型按照类的形式进行操作。 但是，以上的八种包装类也是分为两种大的类型的：

· Number：Integer、Short、Long、Double、Float、Byte 都是 Number 的子类表示是一个 数字。

· Object：Character、Boolean 都是 Object 的直接子类。

### 进制(jdk7)

byte、int、long、和 short 都可以用十进制、16 进制以及 8 进制的方式来表示。

1. 前缀 **0b** 二进制
2. 前缀 **0** 表示 8 进制
3. 前缀 **0x** 代表 16 进制
### 数字下划线(jdk7)

Java 7 开始支持在数字定义时候使用下划线分割，增加了数字的可读性。

```java
int a = 10_000_000;
int b = 10_0000;
```
### 类型转换

#### 自动类型转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

转换从低级到高级。

```java
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double
```

数据类型转换必须满足如下规则：

1. 不能对 boolean 类型进行类型转换。
2. 不能把对象类型转换成不相关类的对象。
3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
4. 转换过程中可能导致溢出或损失精度，例如：

```java
int i =128;
byte b = (byte)i;
```

因为 byte 类型是 8 位，最大值为 127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：

```java
(int)23.7 == 23;
(int)-45.89f == -45
```

#### 强制类型转换

- 条件是转换的数据类型必须是兼容的。
- 格式：`(type)value type`是要强制类型转换后的数据类型

```java
  int i =128;
  byte b = (byte)i;
```

要注意，超出范围的强制转型会得到错误的结果，原因是转型时，高位字节直接被扔掉，仅保留了低位的两个字节

#### 字符串转换

```java
//在Integer类中提供了以下的操作方法：
public static int parseInt(String s) ：将String变为int型数据
//在Float类中提供了以下的操作方法：
public static float parseFloat(String s) ：将String变为Float
//在Boolean 类中提供了以下操作方法：
public static boolean parseBoolean(String s) ：将String变为boolean
```

### 高精度大数字

- java.math.BigDecimal 不可变的，任意精度的带符号十进制数。
- java.math.BigInteger 不可变的任意精度整数

### Optional 类型(jdk8)

Java 8 中新增了 Optional 类用来解决空指针异常。Optional 是一个可以保存 null 的容器对象。通过 isPresent() 方法检测值是否存在，通过 get() 方法返回对象。
## 引用类型

- 在 Java 中，引用类型的变量非常类似于 C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。
- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是 null。
- 一个引用变量可以用来引用任何与之兼容的类型。
- 例子：Site site = new Site("Runoob")。

## 常量

常量在程序运行时是不能被修改的。

在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：

```java
final <数据类型> <变量名> = <值>;

final int NUMBER = 0;
```

虽然常量名也可以用小写，但为了便于识别，通常使用大写字母+下划线表示常量。

## 变量

### 命名规范

关于 Java 标识符，有以下几点需要注意：

- 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（\_）开始
- 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（\_）或数字的任何字符组合
- 关键字不能用作标识符
- 标识符是大小写敏感的
- 合法标识符举例：age、$salary、\_value、\_\_1_value
- 非法标识符举例：123abc、-salary

### 使用

- 声明
- 初始化

```java
<数据类型> <变量名> = <值>  [,<变量名1> = <值1>,....]；

// 可以使用 var 关键字替换变量的类型,让编译器自行推断数据类型
var sb = new StringBuilder();
// 编译器会将以上语句处理为
StringBuilder sb = new StringBuilder();
// 使用var定义变量，仅仅是少写了变量类型而已。
```

### 局部变量

- 局部变量声明在方法、构造方法或者语句块中；
- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
- 访问修饰符不能用于局部变量；
- 局部变量只在声明它的方法、构造方法或者语句块中可见；
- 局部变量是在栈上分配的。
- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

### 实例变量

- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
- 当一个对象被实例化之后，每个实例变量的值就跟着确定；
- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
- 实例变量可以声明在使用前或者使用后；
- 访问修饰符可以修饰实例变量；
- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
- 实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。

### 类变量（静态变量）

- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。
- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
- 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。
- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。
- 静态变量在第一次被访问时创建，在程序结束时销毁。
- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。
- 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
- 静态变量可以通过：*ClassName.VariableName*的方式访问。
- 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。

## 运算符

### 算术运算符

算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。

表格中的实例假设整数变量 A 的值为 10，变量 B 的值为 20：

| 操作符 | 描述 例子                                 |
| :----- | :---------------------------------------- | :-------------- |
| +      | 加法 - 相加运算符两侧的值                 | A + B 等于 30   |
| -      | 减法 - 左操作数减去右操作数               | A – B 等于 -10  |
| \*     | 乘法 - 相乘操作符两侧的值                 | A \* B 等于 200 |
| /      | 除法 - 左操作数除以右操作数               | B / A 等于 2    |
| ％     | 取余 - 左操作数除以右操作数的余数         | B%A 等于 0      |
| ++     | 自增: 操作数的值增加 1 B++ 或 ++B 等于 21 |
| --     | 自减: 操作数的值减少 1 B-- 或 --B 等于 19 |

```Java
int a = 1;
int b = 1;
int resulta = a++; // resulta=1,a=2
int resultb = ++b; // resultb=2,b=2
```

### 关系运算符

下表为 Java 支持的关系运算符

表格中的实例整数变量 A 的值为 10，变量 B 的值为 20：

| 运算符 | 描述 例子                                                             |
| :----- | :-------------------------------------------------------------------- | :--------------- |
| ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。 （A == B）为假。 |
| !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。              | (A != B) 为真。  |
| >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。            | （A> B）为假。   |
| <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。            | （A <B）为真。   |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。      | （A> = B）为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。      | （A <= B）为真。 |

### 位运算符

Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。

位运算符作用在所有的位上，并且按位运算。假设 a = 60，b = 13;它们的二进制格式表示将如下：

```java
A = 0011 1100
B = 0000 1101
-----------------
A&B = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A= 1100 0011

对`byte`和`short`类型进行移位时，会首先转换为`int`再进行位移。
```

下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：

| 操作符 | 描述 例子                                                                              |
| :----- | :------------------------------------------------------------------------------------- | :----------------------------------------------------------------------- |
| ＆     | 如果相对应位都是 1，则结果为 1，否则为 0 （A＆B），得到 12，即 0000 1100               |
| `      | `                                                                                      | 如果相对应位都是 0，则结果为 0，否则为 1 （A \| B）得到 61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为 0，否则为 1 （A ^ B）得到 49，即 0011 0001                |
| `〜`   | 按位取反运算符翻转操作数的每一位，即 0 变成 1，1 变成 0。 （〜A）得到-61，即 1100 0011 |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。 A << 2 得到 240，即 1111 0000     |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。 A >> 2 得到 15 即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。     | A>>>2 得到 15 即 0000 1111                                               |

### 逻辑运算符

下表列出了逻辑运算符的基本运算，假设布尔变量 A 为真，变量 B 为假

| 操作符 | 描述 例子                                                                                 |
| :----- | :---------------------------------------------------------------------------------------- | :----------------- | -------------------------------------------------------------------------------- |
| &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 （A && B）为假。                 |
| `      |                                                                                           | `                  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 （A \| \| B）为真。 |
| ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为 true，则逻辑非运算符将得到 false。 | ！（A && B）为真。 |

### 赋值运算符

下面是 Java 语言支持的赋值运算符：

| 操作符  | 描述 例子                                                                          |
| :------ | :--------------------------------------------------------------------------------- | :--------------------------------------- |
| =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数 C = A + B 将把 A + B 得到的值赋给 C |
| + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数                           | C + = A 等价于 C = C + A                 |
| - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数                           | C - = A 等价于 C = C - A                 |
| \* =    | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数                           | C _ = A 等价于 C = C _ A                 |
| / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数                           | C / = A，C 与 A 同类型时等价于 C = C / A |
| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数                       | C％= A 等价于 C = C％A                   |
| << =    | 左移位赋值运算符 C << = 2 等价于 C = C << 2                                        |
| >> =    | 右移位赋值运算符 C >> = 2 等价于 C = C >> 2                                        |
| ＆=     | 按位与赋值运算符 C＆= 2 等价于 C = C＆2                                            |
| ^ =     | 按位异或赋值操作符 C ^ = 2 等价于 C = C ^ 2                                        |
| \| =    | 按位或赋值操作符 C \| = 2 等价于 C = C \| 2                                        |

### 条件运算符（?:）

条件运算符也被称为三元运算符。该运算符有 3 个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

```java
variable x = (expression) ? value if true : value if false
```

### instanceof 运算符

该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

instanceof 运算符使用格式如下：

```
( Object reference variable ) instanceof  (class/interface type)
```

如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。

### Java 运算符优先级

当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。

例如，（1+3）＋（3+2）\*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。

再如，x = 7 + 3 _ 2;这里 x 得到 13，而不是 20，因为乘法运算符比加法运算符有较高的优先级，所以先计算 3 _ 2 得到 6，然后再加 7。

下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。

| 类别     | 操作符 关联性                               |
| :------- | :------------------------------------------ | :------- |
| 后缀     | () [] . (点操作符) 左到右                   |
| 一元     | expr++ expr-- 从左到右                      |
| 一元     | ++expr --expr + - ～ ！ 从右到左            |
| 乘性     | \* /％ 左到右                               |
| 加性     | + - 左到右                                  |
| 移位     | >> >>> << 左到右                            |
| 关系     | > >= < <= 左到右                            |
| 相等     | == != 左到右                                |
| 按位与   | ＆ 左到右                                   |
| 按位异或 | ^ 左到右                                    |
| 按位或   | \| 左到右                                   |
| 逻辑与   | && 左到右                                   |
| 逻辑或   | \| \| 左到右                                |
| 条件     | ？： 从右到左                               |
| 赋值     | = + = - = \* = / =％= >> = << =＆= ^ = \| = | 从右到左 |
| 逗号     | ， 左到右                                   |
