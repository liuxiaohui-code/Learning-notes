# Java

## 特性与优势

- 简单性
- 面向对象
- 可移植性
- 高性能
- 分布式
- 动态性
- 多线程
- 安全性
- 健壮性

## 三大版本

write once ,run anywhere --- JVM

- JavaSE 标准版 （桌面、控制台）
- JavaME :嵌入式开发
- JavaEE : 企业开发（web 、服务器）

## JDK JRE JVM

```
  ┌─    ┌──────────────────────────────────┐
  │     │     Compiler, debugger, etc.     │
  │     └──────────────────────────────────┘
 JDK ┌─ ┌──────────────────────────────────┐
  │  │  │                                  │
  │ JRE │      JVM + Runtime Library       │
  │  │  │                                  │
  └─ └─ └──────────────────────────────────┘
        ┌───────┐┌───────┐┌───────┐┌───────┐
        │Windows││ Linux ││ macOS ││others │
        └───────┘└───────┘└───────┘└───────┘
```

- JDK : JAVA development kit java 开发者工具
- JRE : JAVA runtime environment java 运行时环境
- JVM : JAVA virtual machine java 虚拟机

JSR 规范：Java Specification Request,SUN 公司
JCP 组织：Java Community Process

JDK 包含 JRE,JRE 包含 JVM

## 开发环境搭建

1. 安装
   1. 下载 jdk8---常用
   2. 记住安装路径
   3. 系统变量 JAVA_HOME: java 安装路径
   4. 系统变量 path: %JAVA_HOME%/bin
   5. 系统变量 path: %JAVA_HOME%/jre/bin
   6. `java -version`
2. 卸载
   1. 删除 java 安装目录
   2. 删除 JAVA_HOME
   3. 删除 path 环境变量
   4. `java -version`

## 工具

细心的童鞋还可以在 JAVA_HOME 的 bin 目录下找到很多可执行文件：

`java` ：这个可执行程序其实就是 JVM，运行 Java 程序，就是启动 JVM，然后让 JVM 执行指定的编译后的代码；
`javac` ：这是 Java 的编译器，它用于把 Java 源码文件（以.java 后缀结尾）编译为 Java 字节码文件（以.class 后缀结尾）；
`jar` ：用于把一组.class 文件打包成一个.jar 文件，便于发布；
`javadoc` ：用于从 Java 源码中自动提取注释并生成文档；
`jdb` ：Java 调试器，用于开发阶段的运行调试。

## Hello world

```java
// Hello.java
public class Hello{
  public static void main(String[] args){
    System.out.println("Hello world !");
  }
}
// javac Hello.java  # 编译，生成.class文件
// java Hello #运行字节码文件


// Java 11 可以直接运行一个Java文件

// 入口函数
// main()方法一直写到了今天：
public static void main(String args[]){}
以上的各个参数的含义如下：
· public：表示公共的内容，可以被所有操作所调用
· static：表示方法是静态的，可以由类名称直接调用。java StaticDemo09
· void：表示没有任何的返回值操作
· main：系统规定好的方法名称。如果main写错了或没有，会报错：NoSuchMethodError: main
· String[] args：字符串数组，接收命令行参数的
  args[0] 为程序名
```

注意：

- **大小写敏感**：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。
- **类名**：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 **MyFirstJavaClass** 。
- **方法名**：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- **源文件名**：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 **.java**。（如果文件名和类名不相同则会导致编译错误）。
- **主方法入口**：所有的 Java 程序由 **public static void main(String[] args)** 方法开始执行。
- 注释：`//单行 /*多行*/`

## java 运行机制

- 编译型
- 解释型

_.java -> java 编译器： _.class 字节码文件 -> 类加载器 -> 字节码校验器 -> 解释器 -> 操作系统平台

## java 命令

```sh
# 编译,得到.class字节码文件
javac [-encoding UTF-8] <程序名.java>
# 运行
java <程序名.class> [参数1 参数2 ...]

javac MyFirstClass.java
java MyFirstClass
# java 11 以上
java MyFirstClass.java
```

## davadoc

`@author` 标识一个类的作者，一般用于类注释 @author description
`@deprecated` 指名一个过期的类或成员，表明该类或方法不建议使用 @deprecated description
`@version` 指定类的版本，一般用于类注释 @version info
`@since` 说明从哪个版本起开始有了这个函数 @since release
`@throws` 和 @exception 标签一样. The @throws tag has the same meaning as the @exception tag.
`@return` 说明返回值类型，一般用于方法注释，不能出现再构造方法中 @return explanation
`@exception` 可能抛出异常的说明，一般用于方法注释 @exception exception-name explanation
`{@docRoot}` 指明当前文档根目录的路径 Directory Path
`{@inheritDoc}` 从直接父类继承的注释 Inherits a comment from the immediate surperclass.
`{@link}` 插入一个到另一个主题的链接 {@link name text}
`{@linkplain}` 插入一个到另一个主题的链接，但是该链接显示纯文本字体 Inserts an in-line link to another topic.
`{@value}` 显示常量的值，该常量必须是 static 属性。 Displays the value of a constant, which must be a static field.
`@param` 说明一个方法的参数，一般用于方法注释 @param parameter-name explanation
`@see` 指定一个到另一个主题的链接 @see anchor
`@serial` 说明一个序列化属性 @serial description
`@serialData` 说明通过 writeObject() 和 writeExternal() 方法写的数据 @serialData description
`@serialField` 说明一个 ObjectStreamField 组件 @serialField name type description

javadoc 参数 java 文件
javadoc [options] [packagenames] [sourcefiles]

javadoc --help

常用：
`javadoc -encoding UTF-8 -charest UTF-8 *.java`

## jar

```sh
https://www.cnblogs.com/mq0036/p/8566427.html#a11

$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar
$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
       -jar target/myapplication-0.0.1-SNAPSHOT.jar

```

# 数据类型与变量

## 内置类型

Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

### byte 1

- byte 数据类型是 8 位、有符号的，以二进制补码表示的整数；
- 最小值是 **-128（-2^7）**；
- 最大值是 **127（2^7-1）**；
- 默认值是 **0**；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
- 例子：byte a = 100，byte b = -50。

### short 2

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 **-32768（-2^15）**；
- 最大值是 **32767（2^15 - 1）**；
- Short 数据类型也可以像 byte 那样节省空间。一个 short 变量是 int 型变量所占空间的二分之一；
- 默认值是 **0**；
- 例子：short s = 1000，short r = -20000。

### int 4

- int 数据类型是 32 位、有符号的以二进制补码表示的整数；
- 最小值是 **-2,147,483,648（-2^31）**；
- 最大值是 **2,147,483,647（2^31 - 1）**；
- 一般地整型变量默认为 int 类型；
- 默认值是 **0** ；
- 例子：int a = 100000, int b = -200000。

### long 8

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；
- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 **0L**；
- 例子： **long a = 100000L**，**long b = -200000L**。
  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

### float 4

- float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 **0.0f**；
- 浮点数不能用来表示精确的值，如货币；
- 例子：float f1 = 234.5f。

### double 8

- double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；
- 浮点数的默认类型为 double 类型；
- double 类型同样不能表示精确的值，如货币；
- 默认值是 **0.0d**；

- 例子：

  ```
  double   d1  = 7D ;
  double   d2  = 7.;
  double   d3  =  8.0;
  double   d4  =  8.D;
  double   d5  =  12.9867;
  ```

  7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。

### boolean

- boolean 数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 **false**；
- 例子：boolean one = true。
- Java 语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要 1 bit，但是通常 JVM 内部会把 boolean 表示为 4 字节整数。

### char 2

- char 类型是一个单一的 16 位 Unicode 字符；
- 最小值是 **\u0000**（十进制等效值为 0）；
- 最大值是 **\uffff**（即为 65535）；
- char 数据类型可以储存任何字符；

```java
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013
// 注意是十六进制:直接用转义字符\u+Unicode编码来表示一个字符
char c3 = '\u0041'; // 'A'，因为十六进制0041 = 十进制65
char c4 = '\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013
```

因为 Java 在内存中总是使用`Unicode`表示字符，所以，一个英文字符和一个中文字符都用一个 char 类型表示，它们都占用两个字节。要显示一个字符的 Unicode 编码，只需将 char 类型直接赋值给 int 类型即可：

### 包装类

1. 基本类型的包装类
2. jdk1.5 自动装箱与拆箱
3. `Integer` `==`比较;为了节省内存，`Integer.valueOf()`对于较小的数`(<128)`，**始终返回相同的实例**，因此，`==`比较“恰好”为`true`，所以必须使用 `equals()`比较包装类
4. 创建包装类对象优先使用`Integer.valueOf()` 静态工厂的方式,而不是 `new` 操作符

在 Java 中有一个设计的原则“一切皆对象”，那么这样一来 Java 中的一些基本的数据类型，就完全不符合于 这种设计思想，因为 Java 中的八种基本数据类型并不是引用数据类型，所以 Java 中为了解决这样的问题， 引入了八种基本数据类型的包装类。

```
序号 基本数据类型 包装类
1 		int 			Integer
2 		char 			Character
3 		float 		Float
4 		double		Double
5 		boolean 	Boolean
6 		byte 			Byte
7 		short 		Short
8 		long 			Long
```

以上的八种包装类，可以将基本数据类型按照类的形式进行操作。 但是，以上的八种包装类也是分为两种大的类型的：

· Number：Integer、Short、Long、Double、Float、Byte 都是 Number 的子类表示是一个 数字。

· Object：Character、Boolean 都是 Object 的直接子类。

### 进制

byte、int、long、和 short 都可以用十进制、16 进制以及 8 进制的方式来表示。

1. 前缀 **0b** 二进制
2. 前缀 **0** 表示 8 进制
3. 前缀 **0x** 代表 16 进制

### 类型转换

#### 自动类型转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

转换从低级到高级。

```java
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double
```

数据类型转换必须满足如下规则：

1. 不能对 boolean 类型进行类型转换。
2. 不能把对象类型转换成不相关类的对象。
3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
4. 转换过程中可能导致溢出或损失精度，例如：

```java
int i =128;
byte b = (byte)i;
```

因为 byte 类型是 8 位，最大值为 127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：

```java
(int)23.7 == 23;
(int)-45.89f == -45
```

#### 强制类型转换

- 条件是转换的数据类型必须是兼容的。
- 格式：`(type)value type`是要强制类型转换后的数据类型

```java
  int i =128;
  byte b = (byte)i;
```

要注意，超出范围的强制转型会得到错误的结果，原因是转型时，高位字节直接被扔掉，仅保留了低位的两个字节

#### 字符串转换

```java
//在Integer类中提供了以下的操作方法：
public static int parseInt(String s) ：将String变为int型数据
//在Float类中提供了以下的操作方法：
public static float parseFloat(String s) ：将String变为Float
//在Boolean 类中提供了以下操作方法：
public static boolean parseBoolean(String s) ：将String变为boolean
```

### 高精度大数字

- java.math.BigDecimal 不可变的，任意精度的带符号十进制数。
- java.math.BigInteger 不可变的任意精度整数

## 引用类型

- 在 Java 中，引用类型的变量非常类似于 C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。
- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是 null。
- 一个引用变量可以用来引用任何与之兼容的类型。
- 例子：Site site = new Site("Runoob")。

## 常量

常量在程序运行时是不能被修改的。

在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：

```java
final <数据类型> <变量名> = <值>;

final int NUMBER = 0;
```

虽然常量名也可以用小写，但为了便于识别，通常使用大写字母+下划线表示常量。

## 变量

### 命名规范

关于 Java 标识符，有以下几点需要注意：

- 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（\_）开始
- 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（\_）或数字的任何字符组合
- 关键字不能用作标识符
- 标识符是大小写敏感的
- 合法标识符举例：age、$salary、\_value、\_\_1_value
- 非法标识符举例：123abc、-salary

### 使用

- 声明
- 初始化

```java
<数据类型> <变量名> = <值>  [,<变量名1> = <值1>,....]；

// 可以使用 var 关键字替换变量的类型,让编译器自行推断数据类型
var sb = new StringBuilder();
// 编译器会将以上语句处理为
StringBuilder sb = new StringBuilder();
// 使用var定义变量，仅仅是少写了变量类型而已。
```

### 局部变量

- 局部变量声明在方法、构造方法或者语句块中；
- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
- 访问修饰符不能用于局部变量；
- 局部变量只在声明它的方法、构造方法或者语句块中可见；
- 局部变量是在栈上分配的。
- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

### 实例变量

- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
- 当一个对象被实例化之后，每个实例变量的值就跟着确定；
- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
- 实例变量可以声明在使用前或者使用后；
- 访问修饰符可以修饰实例变量；
- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
- 实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。

### 类变量（静态变量）

- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。
- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
- 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。
- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。
- 静态变量在第一次被访问时创建，在程序结束时销毁。
- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。
- 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
- 静态变量可以通过：*ClassName.VariableName*的方式访问。
- 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。

## 运算符

### 算术运算符

算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。

表格中的实例假设整数变量 A 的值为 10，变量 B 的值为 20：

| 操作符 | 描述 例子                                 |
| :----- | :---------------------------------------- | :-------------- |
| +      | 加法 - 相加运算符两侧的值                 | A + B 等于 30   |
| -      | 减法 - 左操作数减去右操作数               | A – B 等于 -10  |
| \*     | 乘法 - 相乘操作符两侧的值                 | A \* B 等于 200 |
| /      | 除法 - 左操作数除以右操作数               | B / A 等于 2    |
| ％     | 取余 - 左操作数除以右操作数的余数         | B%A 等于 0      |
| ++     | 自增: 操作数的值增加 1 B++ 或 ++B 等于 21 |
| --     | 自减: 操作数的值减少 1 B-- 或 --B 等于 19 |

```Java
int a = 1;
int b = 1;
int resulta = a++; // resulta=1,a=2
int resultb = ++b; // resultb=2,b=2
```

### 关系运算符

下表为 Java 支持的关系运算符

表格中的实例整数变量 A 的值为 10，变量 B 的值为 20：

| 运算符 | 描述 例子                                                             |
| :----- | :-------------------------------------------------------------------- | :--------------- |
| ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。 （A == B）为假。 |
| !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。              | (A != B) 为真。  |
| >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。            | （A> B）为假。   |
| <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。            | （A <B）为真。   |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。      | （A> = B）为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。      | （A <= B）为真。 |

### 位运算符

Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。

位运算符作用在所有的位上，并且按位运算。假设 a = 60，b = 13;它们的二进制格式表示将如下：

```java
A = 0011 1100
B = 0000 1101
-----------------
A&B = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A= 1100 0011

对`byte`和`short`类型进行移位时，会首先转换为`int`再进行位移。
```

下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：

| 操作符 | 描述 例子                                                                              |
| :----- | :------------------------------------------------------------------------------------- | :----------------------------------------------------------------------- |
| ＆     | 如果相对应位都是 1，则结果为 1，否则为 0 （A＆B），得到 12，即 0000 1100               |
| `      | `                                                                                      | 如果相对应位都是 0，则结果为 0，否则为 1 （A \| B）得到 61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为 0，否则为 1 （A ^ B）得到 49，即 0011 0001                |
| `〜`   | 按位取反运算符翻转操作数的每一位，即 0 变成 1，1 变成 0。 （〜A）得到-61，即 1100 0011 |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。 A << 2 得到 240，即 1111 0000     |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。 A >> 2 得到 15 即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。     | A>>>2 得到 15 即 0000 1111                                               |

### 逻辑运算符

下表列出了逻辑运算符的基本运算，假设布尔变量 A 为真，变量 B 为假

| 操作符 | 描述 例子                                                                                 |
| :----- | :---------------------------------------------------------------------------------------- | :----------------- | -------------------------------------------------------------------------------- |
| &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 （A && B）为假。                 |
| `      |                                                                                           | `                  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 （A \| \| B）为真。 |
| ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为 true，则逻辑非运算符将得到 false。 | ！（A && B）为真。 |

### 赋值运算符

下面是 Java 语言支持的赋值运算符：

| 操作符  | 描述 例子                                                                          |
| :------ | :--------------------------------------------------------------------------------- | :--------------------------------------- |
| =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数 C = A + B 将把 A + B 得到的值赋给 C |
| + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数                           | C + = A 等价于 C = C + A                 |
| - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数                           | C - = A 等价于 C = C - A                 |
| \* =    | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数                           | C _ = A 等价于 C = C _ A                 |
| / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数                           | C / = A，C 与 A 同类型时等价于 C = C / A |
| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数                       | C％= A 等价于 C = C％A                   |
| << =    | 左移位赋值运算符 C << = 2 等价于 C = C << 2                                        |
| >> =    | 右移位赋值运算符 C >> = 2 等价于 C = C >> 2                                        |
| ＆=     | 按位与赋值运算符 C＆= 2 等价于 C = C＆2                                            |
| ^ =     | 按位异或赋值操作符 C ^ = 2 等价于 C = C ^ 2                                        |
| \| =    | 按位或赋值操作符 C \| = 2 等价于 C = C \| 2                                        |

### 条件运算符（?:）

条件运算符也被称为三元运算符。该运算符有 3 个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

```java
variable x = (expression) ? value if true : value if false
```

### instanceof 运算符

该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

instanceof 运算符使用格式如下：

```
( Object reference variable ) instanceof  (class/interface type)
```

如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。

### Java 运算符优先级

当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。

例如，（1+3）＋（3+2）\*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。

再如，x = 7 + 3 _ 2;这里 x 得到 13，而不是 20，因为乘法运算符比加法运算符有较高的优先级，所以先计算 3 _ 2 得到 6，然后再加 7。

下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。

| 类别     | 操作符 关联性                               |
| :------- | :------------------------------------------ | :------- |
| 后缀     | () [] . (点操作符) 左到右                   |
| 一元     | expr++ expr-- 从左到右                      |
| 一元     | ++expr --expr + - ～ ！ 从右到左            |
| 乘性     | \* /％ 左到右                               |
| 加性     | + - 左到右                                  |
| 移位     | >> >>> << 左到右                            |
| 关系     | > >= < <= 左到右                            |
| 相等     | == != 左到右                                |
| 按位与   | ＆ 左到右                                   |
| 按位异或 | ^ 左到右                                    |
| 按位或   | \| 左到右                                   |
| 逻辑与   | && 左到右                                   |
| 逻辑或   | \| \| 左到右                                |
| 条件     | ？： 从右到左                               |
| 赋值     | = + = - = \* = / =％= >> = << =＆= ^ = \| = | 从右到左 |
| 逗号     | ， 左到右                                   |

# 流程语句

## 循环

### 循环方式

1. `while`
2. `do...while`
3. `for(::)`
4. `for(:)`

```java
// ---- 1 ----
while( 布尔表达式 ) {
  //循环内容
}

// ---- 2 ----
do {
       //代码语句
}while(布尔表达式);

// ---- 3 ----
for(初始条件; 循环检测条件; 循环后更新计数器) {
    //代码语句
}

// ---- 4 jdk1.5 数组、集合 ----
for(声明语句 : 表达式)
{
   //代码句子
}
```

### 循环控制

- `break`
- `continue`

## 分支

### if-else

```java
if(布尔表达式 1){
   //如果布尔表达式 1的值为true执行代码
}else if(布尔表达式 2){
   //如果布尔表达式 2的值为true执行代码
}else if(布尔表达式 3){
   //如果布尔表达式 3的值为true执行代码
}else {
   //如果以上布尔表达式都不为true执行代码
}
```

### switch-case

```js
switch (expression) {
	case value:
		//语句
		break //可选
	case value:
		//语句
		break //可选
	//你可以有任意数量的case语句
	default: //可选
	//语句
}
```

- switch 语句中的变量类型可以是： `byte` `short` `int` 或者 `char`; Java SE 7 开始，switch 支持字符串 `String` 类型了，同时 `case` 标签必须为**字符串常量**或**字面量**。

从**Java 12**开始，switch 语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要 break 语句：**新语法只会执行匹配的语句，没有穿透效应**。

```java
String fruit =  "apple";
switch(fruit){
  case "apple" -> System.out.println("selected apple");
  case "pear" -> System.out.println("selected pear");
  case "mango" ->{
    System.out.println("good selected ");
    System.out.println("selected mango");
  }
  default -> System.out.println("no fruit selected");
}

使用新的switch语法，不但不需要break，还可以直接返回值:
int x = switch(1){
  case 1 -> 2;
  case 2 -> {
    int code = hash(2);
    yield code; // 但是，如果需要复杂的语句，我们也可以写很多语句，放到{…}里，然后，用yield返回一个值作为switch语句的返回值
  }
  default -> 0;
}
// x = 2;

// 由于switch表达式是作为Java 13的预览特性（Preview Language Features）实现的，编译的时候，我们还需要给编译器加上参数：

javac --source 13 --enable-preview Main.java
```

# 数组

- 数组是**引用类型**，并且**数组大小不可变**;

## 基本使用

```java
//数组声明
//默认值 null
int[] array; // 首选的方法
//或
int array[];  // 效果相同，但不是首选方法

// 数组定义,必须给数组长度;
int[] xs = new int[5];

// 数组赋值
xs[0] = 0;
xs[1] = 1;
xs[2] = 2;
xs[3] = 3;
xs[4] = 4;

// 定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小
int[] xs = {0,1,2,3,4,5};
int[] xs = new int[] {0,1,2,3,4,5};

// 数组长度
int length = xs.length;
```

## 遍历

```java
int[] xs = {0,1,2,3,4,5};
// for
for(int i = 0;i<xs.length;i++){
  System.out.print(xs[i]+"\t");
}
// for each
for(int el : xs){
  System.out.print(el+"\t");
}
// Arrays.toString()
Arrays.toString(xs)
```

## 排序

### 冒泡排序

```java
int[] ns = {18, 12, 89, 73, 65, 18, 96, 50, 8, 36};
System.out.println("排序前:" + Arrays.toString(ns));
// 外层循环 length-1 次(选最值)
int temp;
for (int i = 0; i < ns.length - 1; i++) {
    // 内层循环 ns.length-1-i 次(比较交换相邻值)
    for (int j = 0; j < ns.length - 1 - i; j++) {
        temp = ns[j];
        if (temp > ns[j + 1]) {
            ns[j] = ns[j + 1];
            ns[j + 1] = temp;
        }
    }
}
System.out.println("从小到大排序后:" + Arrays.toString(ns));
```

## 多维数组

二维数组

```java
  String[][] str = new String[3][4];
  // 直接为每一维分配空间，格式如下：
  type[][] typeName = new type[typeLength1][typeLength2];
  //type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数。

  //从最高维开始，分别为每一维分配空间，例如：
  String[][] s = new String[2][];
  s[0] = new String[2];
  s[1] = new String[3];
  s[0][0] = new String("Good");
  s[0][1] = new String("Luck");
  s[1][0] = new String("to");
  s[1][1] = new String("you");
  s[1][2] = new String("!");


  int[][] ns = {
    {1,2,3},
    {1,2,3},
    {1,2,3},
    {1,2,3},
  };
  // 多维数组打印
  System.out.println(Arrays.deepToString(ns));
```

## 数组操作类

- java.util.Arrays 该类包含用于操作数组的各种方法

## 稀疏数组

一个二维数组有很多 0 或者相同的数字，可以使用稀疏数组进行压缩。
稀疏数组: 记录数组的行列数、有效数字总数、有效数字的坐标以及元素值
生成稀疏数组的步骤：

1. 一个二维数组，`x[11][11]`
2. 稀疏数组：`y[x有效元素总数][3]`
3. `y[0] = {x.length,x[1].length,x元素有效总数}`
4. x 中的一个有效元素 2：(1,3) `y[1] = {1,3,2}`

# 面对对象

## 概念

面向对象思想从**概念**上讲分为以下三种：OOA、OOD、OOP

- `OOA` ：面向对象分析（Object Oriented Analysis）
- `OOD` ：面向对象设计（Object Oriented Design）
- `OOP` ：面向对象程序（Object Oriented Programming

三大**特征**：

- `封装性` ：所有的内容对外部不可见 private 与 getter setter
- `继承性` ：将其他的功能继承下来继续发展 extends
- `多态性` ：方法的重载本身就是一个多态性的体现 interface implements

类与对象：

​ 类表示一个共性的产物，是一个综合的特征，而对象，是一个个性的产物，是一个个体的特征。 （类似生活中的图纸与实物的概念。） 类必须通过对象才可以使用，对象的所有操作都在类中定义。 类由属性和方法组成：

​ · 属性：就相当于人的一个个的特征

​ · 方法：就相当于人的一个个的行为，例如：说话、吃饭、唱歌、睡觉

this：

​ · 调用类中的属性

​ · 调用类中的方法或构造方法

​ · 表示当前对象

## 创建

### 类定义

```java
// <类名>.java  文件名与类名保持一致，一个文件一个类
<访问控制> class <类名> { //类名使用大驼峰

	//构造函数
  <类名>(参数列表){}  //无返回值

	//类属性，使用： <类名>.<属性名>
  <访问控制> static <数据类型> <属性名>;

  //类方法，使用： <类名>.<方法名>();
  <访问控制> static <返回值类型> <方法名> (参数列表){}

  //成员属性，使用： <对象名>.<属性名>
  <访问控制> <数据类型> <属性名>;

  //成员方法，使用： <对象名>.<方法名>();
  <访问控制> <返回值类型> <方法名> (参数列表){}
}

public class Person {
  // 属性
  public String name;
  public int age;
  // 构造方法
  Person(){}
  // 成员方法
  public void func(){}
  // 静态代码块
  static {}
  // 构造代码块
  {}
  // 类方法
  public static void func1(){}

}
```

当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则。

- 一个源文件中只能有一个 `public` 类
- 一个源文件可以有多个非 `public` 类
- 源文件的名称应该和 `public` 类的类名保持一致。例如：源文件中 `public` 类的类名是 `Employee` ，那么源文件应该命名为 `Employee.java`。
- 如果一个类定义在某个包中，那么 `package` 语句应该在源文件的首行。
- 如果源文件包含 `import` 语句，那么应该放在 `package` 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。
- import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。

### 对象创建

```java
Person p = new Person();
```

### 代码块

**普通代码块**
在执行的流程中 出现的 代码块， 我们称其为普通代码块。
**构造代码块**
在类中的成员代码块， 我们称其为构造代码块， 在每次对象创建时执行， 执行在构造方法之前。
**静态代码块**
在类中使用 static 修饰的成员代码块， 我们称其为静态代码块， 在类加载时执行。 每次程序启动到关闭 ，只会执行一次的代码块。
**同步代码块**

构造方法 与 构造代码块 以及 静态代码块的执行顺序：**静态代码块 --> 构造代码块 --> 构造方法**

### 属性

**成员属性**
**静态属性**
用 `static` 修饰的字段，称为静态字段：实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。使用`类名.静态字段`访问;

### 访问控制

Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

- **private** : 在同一类内可见。使用对象：变量、方法。 **同类**
- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。**同类、同包**
- **protected** : 作用于继承关系。定义为 protected 的字段和方法可以被子类访问，以及子类的子类。使用对象：变量、方法。 **子类**；
- **public** : 对所有类可见。使用对象：类、接口、变量、方法

## 方法

### 可变参数

一个方法中定义完了参数，则在调用的时候必须传入与其一一对应的参数，但是在 JDK 1.5 之后提供了新的
功能，可以根据需要自动传入任意个数的参数。
语法：

```java
返回值类型 方法名称(数据类型 …参数名称){
//参数在方法内部 ， 以数组的形式来接收
}
```

注意：
可变参数只能出现在参数列表的最后。

### 构造方法

作用：用于对象初始化。
执行时机：在创建对象时,自动调用
特点:

1. 所有的 Java 类中都会至少存在一个构造方法
2. 如果一个类中没有明确的编写构造方法, 则编译器会自动生成一个无参的构造方法, 构造方法中没有任何的代码！
3. 如果自行编写了任意一个构造器, 则编译器不会再自动生成无参的构造方法
4. **子类的构造方法在被调用时,会默认调用父类的无参构造函数;**

```java
public class Person {
  public Person(){
    // 子类构造函数第一行默认调用了父类的构造函数
    super();
  }
}
```

### 静态方法(类方法)

静态方法属于 class 而不属于实例，因此，**静态方法内部，无法访问 this 变量，也无法访问实例字段，它只能访问静态字段**。通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。

## 封装

通过 private 关键字控制成员属性和方法,只用通过特定的方法才能访问这些属性;
常用的操作:

```java
public class Person{
  private String name;
  public void setName(String name){
    this.name = name;
  }
  public String getName(){
    return name;
  }
}
```

## 继承

特点：

1. 单继承
2. 子类拥有父类的 `public`,`protected` 方法和属性
3. 子类可以**重写**父类方法
4. 通过 `this` 关键字调用成员方法和属性,常用于成员方法的参数与成员属性名冲突;
5. 通过 `super` 访问父类的方法和属性,包括被子类重写的方法和属性;
6. 通过 `final` 修饰类和方法,防止子类继承和重写;

```java
class 类名 extends 父类 {
  类名(){
    //子类的构造方法第一行默认调用了 super()
    super()
  }
}
class Person{}
class Student extends Person{}
Person p = new Person();
Student s = new Student();
// 向上转型
Person p = new Student();
// 向下转型
Person p1 = new Student(); // upcasting, ok
Person p2 = new Person();
Student s1 = (Student) p1; // ok
Student s2 = (Student) p2; // runtime error! ClassCastException!
// 为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型：
Person p = new Student();
if (p instanceof Student) {
    // 只有判断成功才会向下转型:
    Student s = (Student) p; // 一定会成功
}
```

## 多态

多态：就是对象的多种表现形式，（多种体现形态）
对象的多态性，从概念上非常好理解，在类中有子类和父类之分，子类就是父类的一种形态 ，对象多态性
就从此而来。
ps: 方法的重载 和 重写 也是多态的一种， 不过是方法的多态（相同方法名的多种形态）。
重载： 一个类中方法的多态性体现
重写： 子父类中方法的多态性体现。

### 重载

方法的重载 ,可以让我们在不同的需求下, 通过传递不同的参数调用方法来完成具体的功能。

1. **方法名称**相同, **参数类型**或**参数个数**不同
2. **方法的重载与返回值无关!**

### 重写

1. 重写是方法的重写，与属性无关
2. 前提：继承，子类重写父类的方法
3. 返回值、方法名、参数表相同
4. 修饰符：范围可以扩大，但不可以缩小 `public` > `protected` >`default` > `private`
5. `@Override`

需要重写的原因：

1. 父类的功能子类不需要，或者不一定满足

### final

继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为 final。

1. 标记方法: **用 final 修饰的方法不能被子类重写**
2. 标记类: **用 final 修饰的类不能被继承**
3. 标记属性:**在初始化后不能被修改**,可以在构造方法中初始化 final 字段

## 抽象类 abstract

抽象类必须使用`abstract class`声明,**一个抽象类中可以没有抽象方法,但是抽象方法必须写在抽象类或者接口中。**
格式：

```java
abstract class 类名{ // 抽象类
  public abstract void 方法名() ; // 抽象方法，只声明而未实现
}
```

**在抽象类的使用中有几个原则：**

· 抽象类本身是不能直接进行实例化操作的，即：不能直接使用关键字 new 完成。

· 一个抽象类必须被子类所继承，被继承的子类（如果不是抽象类）则必须覆写(重写)抽象类中的全部抽象方法。

**1、 抽象类能否使用 final 声明？**

​ 不能，因为 final 属修饰的类是不能有子类的 ， 而抽象类必须有子类才有意义，所以不能。

**2、 抽象类能否有构造方法？**

```
能有构造方法，而且子类对象实例化的时候的流程与普通类的继承是一样的，都是要先调用父类中的构造方法（默认是无参的），之后再调用子类自己的构造方法。
```

**抽象类与普通类的区别：**

```
1、抽象类必须用public或procted 修饰(如果为private修饰，那么子类则无法继承，也就无法实现其 抽象方法）。默认缺省为 public

2、抽象类不可以使用new关键字创建对象， 但是在子类创建对象时， 抽象父类也会被JVM实例化。

3、如果一个子类继承抽象类，那么必须实现其所有的抽象方法。如果有未实现的抽象方法，那么子类也必须定义为 abstract类
```

## 内部类

在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。 广泛意义上的内部类一般来说包括这四种：

​ 1、成员内部类

​ 2、局部内部类

​ 3、匿名内部类 （终点）

​ 4、静态内部类

### 成员内部类

```java
成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：
class Outer {
	private double x = 0;
	public Outer(double x) {
		this.x = x;
	}
	class Inner { //内部类
		public void say() {
			System.out.println("x="+x);
		}
	}
}
特点： 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。
不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：
		外部类.this.成员变量
		外部类.this.成员方法
```

### 局部内部类

```
	局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
	注意:局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。
```

### 匿名内部类

```java
匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：
new 父类构造器（参数列表）|实现接口（）
{
//匿名内部类的类体部分
}
在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。

在使用匿名内部类的过程中，我们需要注意如下几点：
1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能
继承一个类或者实现一个接口。
2、匿名内部类中是不能定义构造函数的。
3、匿名内部类中不能存在任何的静态成员变量和静态方法。
4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。
5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
6、只能访问final型的局部变量
```

### 静态内部类

```
静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。
静态内部类是不需要依赖于外部类对象的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法.
```

## 包

我们使用 `package` 来解决名字冲突。

Java 定义了一种名字空间，称之为包： `package` 。一个类总是属于某个包，类名（比如 Person）只是一个简写，真正的完整类名是`包名.类名`。在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。

包可以是多层结构，用`.`隔开。例如：`java.util`。

要特别注意：**包没有父子关系**。java.util 和 java.util.zip 是不同的包，两者没有任何继承关系。

**没有定义包名的 class，它使用的是默认包**，非常容易引起名字冲突，因此，不推荐不写包名的做法。

我们还需要按照包结构把上面的 Java 文件组织起来。假设以 package_sample 作为根目录，src 作为源码目录，那么所有文件结构就是：

```
package_sample
└─ src
    ├─ hong
    │  └─ Person.java
    │  ming
    │  └─ Person.java
    └─ mr
       └─ jun
          └─ Arrays.java

即所有Java文件对应的目录层次要和包的层次一致。
```

**编译**: `javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java`

使用其他包的方式:

1. 直接写完整类名 `mr.jun.Arrays arrays = new mr.jun.Arrays();`
2. `import`: `import mr.jun.Arrays; Arrays arrays = new Arrays();`;可以使用`*`，表示把这个包下面的所有 class 都导入进来
3. `import static`,可以导入一个类的静态字段和静态方法;`import static java.lang.System.*;out.println("Hello, world!");`

Java 编译器最终编译出的`.class` 文件只使用完整类名，因此，在代码中，当编译器遇到一个 class 名称时：

1. 如果是`完整类名`，就直接根据完整类名查找这个 class；
2. 如果是`简单类名`，按下面的顺序依次查找：
   1. 查找当前 `package` 是否存在这个 class；
   2. 查找 `import` 的包是否包含这个 class；
   3. 查找 `java.lang` 包是否包含这个 class。
      如果按照上面的规则还无法确定类名，则编译报错。

编写 class 的时候，编译器会自动帮我们做两个 import 动作：

1. 默认自动 import 当前 package 的其他 class；
2. 默认自动 import java.lang.\*。

## classpath 和 jar

classpath 是 JVM 用到的一个环境变量，它用来指示 JVM 如何搜索 class。
因为 Java 是编译型语言，源码文件是.java，而编译后的.class 文件才是真正可以被 JVM 执行的字节码。因此，JVM 需要知道，如果要加载一个 abc.xyz.Hello 的类，应该去哪搜索对应的 Hello.class 文件。
现在我们假设 classpath 是`.;C:\work\project1\bin;C:\shared`，当 JVM 在加载 `abc.xyz.Hello` 这个类时，会依次查找：

1. `<当前目录>\abc\xyz\Hello.class`
2. `C:\work\project1\bin\abc\xyz\Hello.class`
3. `C:\shared\abc\xyz\Hello.class`

classpath 的设定方法有两种：

1. 在系统环境变量中设置 classpath 环境变量，不推荐；
2. 在启动 JVM 时设置 classpath 变量，推荐。
   1. `java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello`;简写:`java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello`
   2. `java abc.xyz.Hello` 默认 classpath 为`.`即当前目录;

如果有很多`.class`文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。`jar`包就是用来干这个事的，它**可以把 package 组织的目录层级，以及各个目录下的所有文件（包括.class 文件和其他文件）都打成一个 jar 文件**，这样一来，无论是备份，还是发给客户，就简单多了。

jar 包实际上就是一个`zip`格式的压缩文件，而 jar 包相当于目录。如果我们要执行一个 jar 包的 class，就可以把 jar 包放到 classpath 中：`java -cp ./hello.jar abc.xyz.Hello`

制作 jar 包:将所有 class 文件添加到一个 zip 压缩文件,然后修改后缀名为`.jar`

jar 包还可以包含一个特殊的`/META-INF/MANIFEST.MF`文件，MANIFEST.MF 是纯文本，可以指定 `Main-Class` 和其它信息。JVM 会自动读取这个 MANIFEST.MF 文件，如果存在 Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令：`java -jar hello.jar`

jar 包还可以包含其它 jar 包，这个时候，就需要**在 MANIFEST.MF 文件里配置 classpath**了。

在大型项目中，不可能手动编写 MANIFEST.MF 文件，再手动创建 zip 包。Java 社区提供了大量的开源构建工具，例如 Maven，可以非常方便地创建 jar 包。

# 模块 Java9

我们知道，`.class` 文件是 JVM 看到的最小可执行文件，而一个大型程序需要编写很多 Class ，并生成一堆.class 文件，很不便于管理，所以，jar 文件就是 class 文件的容器。

在 Java 9 之前，一个大型 Java 程序会生成自己的 jar 文件，同时引用依赖的第三方 jar 文件，而 JVM 自带的 Java 标准库，实际上也是以 jar 文件形式存放的，这个文件叫 rt.jar，一共有 60 多 M。

如果是自己开发的程序，除了一个自己的 app.jar 以外，还需要一堆第三方的 jar 包，运行一个 Java 程序，一般来说，命令行写这样：`java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main`

**所以，jar 只是用于存放 class 的容器，它并不关心 class 之间的依赖。**

**从 Java 9 开始引入的模块，主要是为了解决“依赖”这个问题。**如果 a.jar 必须依赖另一个 b.jar 才能运行，那我们应该给 a.jar 加点说明啥的，让程序在编译和运行的时候能自动定位到 b.jar，这种自带“依赖关系”的 class 容器就是模块。

为了表明 Java 模块化的决心，从 Java 9 开始，原有的 Java 标准库已经由一个单一巨大的 `rt.jar` 分拆成了几十个模块，这些模块以`.jmod` 扩展名标识，可以在`$JAVA_HOME/jmods` 目录下找到它们：

```
java.base.jmod
java.compiler.jmod
java.datatransfer.jmod
java.desktop.jmod
…
```

这些`.jmod` 文件每一个都是一个模块，模块名就是文件名。例如：模块 `java.base` 对应的文件就是 `java.base.jmod`。模块之间的依赖关系已经被写入到模块内的 `module-info.class` 文件了。**所有的模块都直接或间接地依赖 java.base 模块，只有 java.base 模块不依赖任何模块，它可以被看作是“根模块”**，好比所有的类都是从 Object 直接或间接继承而来。

把一堆 class 封装为 jar 仅仅是一个打包的过程，而把一堆 class 封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是 JNI 扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的 JVM 提供不同的版本。

### 编写模块

```java
oop-module
├── bin
├── build.sh
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java


// module-info.java
module hello.world { // hello.world.jmod
    // requires 引入模块
    requires java.base; // 可不写，任何模块都会自动引入java.base
    requires java.xml;
}
```

```sh
# 编译字节码文件到 bin 目录
$javac -d bin src/module-info.java src/com/itranswarp/sample/*.java
# 把bin目录下的所有class文件先打包成jar,注意传入—main-class参数，让这个jar包能自己定位main方法所在的类
$jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .
# 现在我们就在当前目录下得到了hello.jar这个jar包，它和普通jar包并无区别，可以直接使用命令 来运行它
$java -jar hello.jar
# 打包模块
$jmod create --class-path hello.jar hello.jmod
# 运行模块
$java --module-path hello.jar --module hello.world
Hello, xml!
```

### 用处

1. 打包 jre

过去发布一个 Java 应用程序，要运行它，必须下载一个完整的 JRE，再运行 jar 包。而完整的 JRE 块头很大，有 100 多 M。怎么给 JRE 瘦身呢？

现在，JRE 自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪 JRE 呢？并不是说把系统安装的 JRE 给删掉部分模块，而是“复制”一份 JRE，但只带上用到的模块。为此，JDK 提供了 jlink 命令来干这件事。命令如下：
`$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/`
我们在`—module-path`参数指定了我们自己的模块`hello.jmod`，然后，在`—add-modules`参数中指定了我们用到的 3 个模块`java.base`、`java.xml`和`hello.world`，用,分隔。最后，在`—output`参数指定输出目录。
现在，在当前目录下，我们可以找到 jre 目录，这是一个完整的并且带有我们自己 hello.jmod 模块的 JRE。试试直接运行这个 JRE：

```sh
$ jre/bin/java --module hello.world
Hello, xml!
```

要分发我们自己的 Java 应用程序，只需要把这个 jre 目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装 JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。

### 访问权限

class 的这些访问权限只在一个模块内有效，模块和模块之间，例如，a 模块要访问 b 模块的某个 class，必要条件是 b 模块明确地导出了可以访问的包。

```java
module hello.world {
    exports com.itranswarp.sample; // 到处外部访问需要的类
    requires java.base;
    requires java.xml;
}
```

# 接口 interface

**接口比抽象类更抽象**如果一个类中的全部方法都是抽象方法，全部属性都是全局常量，那么此时就可以将这个类定义成一个接口。
特点:

1. 方法全是抽象方法,属性都是静态常量
2. 多继承
3. 多实现
4. jdk1.8 `default` 方法,实现类可以不必覆写 default 方法。

```java

interface X接口名称 extends A,B{
	[public static final] 全局常量 ;
	[public abstract] 抽象方法 ;
  default void func(int x){}
}
class XImpl implements X,A,B,C,D{
  @Override
}
```

**接口与抽象类的区别**

1、抽象类要被子类继承，接口要被类实现。
2、接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。
3、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
4、抽象类使用继承来使用，无法多继承。 接口使用实现来使用， 可以多实现
5、抽象类中可以包含 static 方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明静态方法）
6、接口不能有构造方法，但是抽象类可以有

## lambda 表达式 (jdk 8)

1. 函数式接口的匿名实现,可以使用 lambda 表达式;
2. lambda 表达式可以转换为匿名类
3. 写法 `(参数表)->{方法体}`
   1. `x->{}` 只有一个参数可以省略()
   2. `()->""` 方法体只有一个返回语句,可以省略{},return 和;号

```java
/**
只有一个接口方法
 */
@FunctionalInterface
interface Operation {
    int operation(int a, int b);
}

class Test {
    private int operate(int a, int b, Operation operation) {
        return operation.operation(a, b);
    }
}

Test test = new Test();

test.operate(1,2,(a,b)->a+b);
```

## 方法引用(jdk8)

通过方法引用，可以使用方法的名字来指向一个方法。使用一对冒号来引 `::` 用方法。

构造方法引用
使用方式：`Class::new`

静态方法引用
使用方式：`Class::staticMethod`

对象的实例方法引用
使用方式：`instance::method`

类的实例方法引用
使用方式：`Class::method`

作用: 指代一个实现函数式接口的匿名对象,要求除函数名可以不一致外,参数表和返回值类型要保持一致

```java
@FunctionalInterface
interface Operation {
    int operation(int a, int b);
}
class x{
  int test(int a, int b){
    return a+b;
  }
  int testA(int a, int b,Operation o){
    return o(a,b);
  }
  @Test
  void testA(){
    testA(1,2,this::test); // 3
  }
}
```

## 默认方法和静态方法(jdk8)

```java
public interface TestInterface {
    String test();

    // 接口默认方法
    default String defaultTest() {
        return "default";
    }
    // 接口静态方法
    static String staticTest() {
        return "static";
    }
}
```

# 枚举

1. 定义的 `enum` 类型总是继承自 `java.lang.Enum`，且无法被继承；
2. 只能定义出 `enum` 的实例，而无法通过 `new` 操作符创建 `enum` 的实例；
3. 定义的每个实例都是引用类型的唯一实例；默认都被 `final、public, static` 修饰
4. 可以将 `enum` 类型用于 `switch` 语句。
5. 注意：枚举类的字段也可以是非 final 类型，即可以在运行期修改，但是不推荐这样做！

```java
// 关键字 eum
public enum Color {
  // 枚举成员 x,y,z,...;
  RED,BLUE,GREEN,BLACK;
}



// 编译器编译出的class大概就像这样
public final class Color extends Enum { // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() {}
}
```

优点:

1. enum 常量本身带有类型信息
2. 不可能引用到非枚举的值，因为无法通过编译
3. 不同类型的枚举不能互相比较或者赋值，因为类型不符。

使得编译器可以在编译期自动检查出所有可能的潜在错误。

## 比较

枚举类是引用类型,可以重重写`equals()`方法进行比较;另外,因为 enum 类型的每个常量在 JVM 中只有一个唯一实例，所以可以直接用`==`比较;

## 常用方法

```java
name() 返回常量名
String s = Weekday.SUN.name(); // "SUN"

toString()  默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。
// 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！

values()	以数组形式返回枚举类型的所有成员

valueOf()	将普通字符串（枚举成员的字符串形式）转换为枚举实例

compareTo()	比较两个枚举成员在定义时的顺序

ordinal()	返回定义的常量的顺序，从0开始计数 //要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段
int n = Weekday.MON.ordinal(); // 1
```

## 为枚举添加方法

```java
enum WeekDay {
  // 枚举的成员，必须先定义，而且使用分号结束
  Mon("Monday"),Tue("Tuesday"),Wed("Wednesday"),Thu("Thursday"),Fri("Friday"),Sat("Saturday"),Sun("Sunday");
  // 属性
  private final String day;
  // 构造函数
  private WeekDay(String day) {
    this.day = day;
  }
  //
  public static void printDay(int i) {
          switch(i) {
              case 1:
                  System.out.println(WeekDay.Mon);
                  break;
              case 2:
                  System.out.println(WeekDay.Tue);
                  break;
              case 3:
                  System.out.println(WeekDay.Wed);
                  break;
              case 4:
                  System.out.println(WeekDay.Thu);
                  break;
              case 5:
                  System.out.println(WeekDay.Fri);
                  break;
              case 6:
                  System.out.println(WeekDay.Sat);
                  break;
              case 7:
                  System.out.println(WeekDay.Sun);
                  break;
              default:
                  System.out.println("wrong number!");
          }
  }

  // 枚举方法
  public String getDay() {
    return day;
  }
  @Override
  public String toString() {
    return this.day ;
  }
}
```

## EnumMap

EnumMap 是专门为枚举类型量身定做的 Map 实现，HashMap 只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值，使得 EnumMap 的效率非常高。

## EnumSet

EnumSet 是枚举类型的高性能 Set 实现，它要求放入它的枚举常量必须属于同一枚举类型。

# 泛型

​ 泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定 义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

- 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前。
- 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
- 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
- 泛型方法体的声明和其他方法一样。注意**类型参数只能代表引用型类型，不能是原始类型**（像 int、double、char 等）。

java 中泛型常用标记符：

- E - Element (在集合中使用，因为集合中存放的是元素)
- T - Type（Java 类）
- K - Key（键）
- V - Value（值）
- N - Number（数值类型）
- ？ - 表示不确定的 java 类型

限制:

1. Java 使用擦拭法实现泛型，导致了：编译器把类型`<T>`视为 Object；编译器根据`<T>`实现安全的强制转型。
2. `<T>`不能是基本类型，例如 int，因为实际类型是 Object，Object 类型无法持有基本类型
3. 无法取得带泛型的 `Class`
4. 无法判断带泛型的 `Class`
5. 一个类可以继承自一个泛型类,在继承了泛型类型的情况下，子类可以获取父类的泛型类型。但是比较复杂

```java
Type genericSuperclass = GenericType.class.getGenericSuperclass();
if (genericSuperclass instanceof ParameterizedType) {
    ParameterizedType pt = (ParameterizedType) genericSuperclass;
    Type[] atas = pt.getActualTypeArguments(); // 可能有多个
    Class<?> ata = (Class<?>) atas[0];
    System.out.println(ata);
}
```

因为 Java 引入了泛型，所以，只用 Class 来标识类型已经不够了

```yaml
Type:
  - Class
  - ParameterizedType # 参数化类型
  - GenericArrayType # 数组类型，其组件类型是参数化类型或类型变量
  - WildcardType # 表示一个通配符型表达，如 ? ， ? extends Number ，或 ? super Integer 。
```

## 泛型使用

泛型类

```java
public class GenericType<T> {
    public T name;

    public static <T> void genericMethod(T x) {
        System.out.println(x);
    }

    public static void main(String[] args) {
        GenericType<String> demo = new GenericType<>();
        demo.name = "name";
        System.out.println(demo.name);

        GenericType.<String>genericMethod("含泛型的静态方法");
    }
}

```

## 泛型限制类型

何时使用 `extends` ，何时使用 super？为了便于记忆，我们可以用 PECS 原则：Producer Extends Consumer Super。

即：如果需要返回 T，它是生产者（Producer），要使用 extends 通配符；如果需要写入 T，它是消费者（Consumer），要使用 super 通配符。

```java
<? extends Parent> 指定了泛型类型的上届
<? super Child> 指定了泛型类型的下届
<?> 指定了没有限制的泛型类型,<?>通配符有一个独特的特点，就是：Pair<?>是所有Pair<T>的超类：
```
