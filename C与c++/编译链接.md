# 流程

.cpp .c ->预处理 -> 编译成汇编语言 ->汇编成目标文件 ->连接成可执行文件

```sh
# 预处理
g++ -E test.cpp -o test.i
# 编译,生成汇编语言文件
g++ -S Test.cpp -o Test.s
# 处理汇编文件为目标文件
g++ -c Test.cpp  -o Test.o
# 目标文件链接库文件生成可执行文件
g++ Test.o -o Test.exe -L F:\vs2008\VC\include\iostream
# 运行
./ Test.exe
```

# 库文件编译

1. 静态链接库: 在写程序调用静态库里包含的函数的时候，编译完就已经把函数的实现放到了产生的 exe 文件里了，所以 exe 后期的运行不需要依赖静态库了，代价就是 exe 体积会变大。目前主流程序一般不用静态库
   1. windows `.lib`
   2. Linux `.a`
2. 动态链接库:在写程序调用动态库里包含的函数的时候，编译阶段只把函数的重定位信息放到了 exe 文件里了，所以 exe 后期的运行需要依赖动态库
   1. windows `.dll`
   2. Linux `.so`

无论是静态库文件还是动态库文件,都是由 .o 文件创建的,所以第一步先编译成.o 目标文件,库文件的命名规范是以 lib 开头（前缀），紧接着是后缀名，静态链接库以 .a 为后缀名 ，动态链接库以.so 为后缀名

```sh
# -fPIC ：表示编译为位置独立的代码。 不用此选项的话编译后的代码是位置相关的，所以动态载入时是通过代码复制的方式 来满足不同进程的需要，而不能达到真正代 码段共享的目的。

# 生成目标文件
g++ -fPIC -o math.o -c math.cpp
# 生成动态链接库
g++ -shared -o libmath.so math.o
# 整合
g++ -fPIC -shared -o libmath.so math.cpp

# 多个文件
g++ fPIC -o add.o -c add.cpp
g++ fPIC -o sub.o -c sub.cpp
g++ -shared -o libmymath.so add.o sub.o
# 整合
g++ -fPIC -shared -o libmymath.so add.cpp sub.cpp

# 静态链接库需要使用 ar 工具
g++ -c math.o math.cpp
ar -cr libmath.a math.o
```

expected one of the following: BITMAP CONTEXT DIRECTORY EDITIONABLE EDITIONING FORCE FUNCTION INDEX MATERIALIZED MULTIVALUE NO NONEDITIONABLE OR PACKAGE PROCEDURE PUBLIC ROLE SEQUENCE SYNONYM TRIGGER TYPE UNIQUE USER VIEW identifier
