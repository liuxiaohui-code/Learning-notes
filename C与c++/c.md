# hello world

```c
#include <stdio.h>

int main(){
    /* 我的第一个 C 程序 */
    printf("Hello, World! \n");
    return 0;
}
// gcc test.c
/*
gcc 进行 c 语言编译分为四个步骤：

1.预处理，生成预编译文件（.i 文件）：

gcc –E hello.c –o hello.i
2.编译，生成汇编代码（.s 文件）：

gcc –S hello.i –o hello.s
3.汇编，生成目标文件（.o 文件）：

gcc –c hello.s –o hello.o
4.链接，生成可执行文件：

gcc hello.o –o hello

5. 执行  ./hello
*/
```

# 数据类型

## 数字

```c
// 整数
char	            1 字节	-128 到 127 或 0 到 255
unsigned char	    1 字节	0 到 255
signed char	      1 字节	-128 到 127
int	              2 或 4 字节	-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647
unsigned int	    2 或 4 字节	0 到 65,535 或 0 到 4,294,967,295
short	            2 字节	-32,768 到 32,767
unsigned short	  2 字节	0 到 65,535
long	            4 字节	-2,147,483,648 到 2,147,483,647
unsigned long	     4 字节	0 到 4,294,967,295
long long         8字节
unsigned long long 8字节

// 进制
前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

// 获取数据类型的存储大小
printf("int 存储大小 : %lu \n", sizeof(int));

// 浮点数
float	4 字节	1.2E-38 到 3.4E+38	6 位有效位
double	8 字节	2.3E-308 到 1.7E+308	15 位有效位
long double	16 字节	3.4E-4932 到 1.1E+4932	19 位有效位
```

## 枚举

它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。

```C
// 注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。
enum　枚举名　{
  枚举元素1,枚举元素2,……
};
枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。

#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7
// 等价于
enum DAY
{
  // 没有指定值的枚举元素，其值为前一元素加 1。
  MON=1, TUE, WED, THU, FRI, SAT, SUN
};

// 枚举类型变量声明
enum DAY day;
enum DAY{} day;
enum {} day;
day = 1
//枚举其实可以直接使用
 printf("枚举值QWER分别是: %d ",MON);
```

## void

- 函数返回为空
- 函数参数为空
- 指针指向 void;类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。

## 派生类型

它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。

## typedef

C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字

```c
typedef unsigned char BYTE;
// 为 unsigned char 取别名 BYTE

#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：

typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。
typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。
```

## 强制类型转换

```c
int a = 1;
double b = a; // 隐式类型转换
a=(int) b; // 强制类型装换
```

# 操作符

## 语句

```c
; // 语句以;结尾
  // 空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。
```

## 注释

```c
// 单行注释
/*
多行注释
*/
```

## 算数

```c
+
-
*
/
%
++
--
```

## 关系

```c
==
!=
<
<=
>
>=
```

## 逻辑

```c
&&
||
!
```

## 位

```c
& 与
| 或
^ 异或,同0异1
~ 取反
<< 左移右补0
>> 右移,正数左补0，负数左补1，右边丢弃。
```

## 赋值

```c
=
<算数|位>=
```

## 杂项

```c
int sizeof(变量|数据类型关键字)  // 返回变量的大小。
& 取地址
* 指向一个变量
?true:false 条件表达式
```

## 优先级

```c
后缀 	() [] -> . ++ - -  	从左到右
一元 	+ - ! ~ ++ - - (type)* & sizeof 	从右到左
乘除 	* / % 	从左到右
加减 	+ - 	从左到右
移位 	<< >> 	从左到右
关系 	< <= > >= 	从左到右
相等 	== != 	从左到右
位与 AND 	& 	从左到右
位异或 XOR 	^ 	从左到右
位或 OR 	| 	从左到右
逻辑与 AND 	&& 	从左到右
逻辑或 OR 	|| 	从左到右
条件 	?: 	从右到左
赋值 	= += -= *= /= %=>>= <<= &= ^= |= 	从右到左
逗号 	, 	从左到右
```

# 语句

## 变量

```c
// 声明,不需要建立存储空间的;
// 作用:
//  1. 在函数内部声明外部变量
//  2. 暴露变量给其他文件使用
extern  <数据类型> <变量1>,...;
// 定义,需要建立存储空间
<数据类型> <变量1>,<变量2>,<变量3>,<变量4>,...;
/** 变量命名规则
1. 由字母,数字,下划线组成,以字母和下划线开头
2. 不与关键字冲突
*/
// 赋值
<已声明的变量> = <赋值>;
// 默认值
int	0
char	'\0'
float	0
double	0
pointer	NULL
```

## 常量

常量又叫字面量

1. 可以是任意数据类型
2. 定义后不能修改
3. 整数常量,整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。
4. 浮点常量;浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
   1. 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。
   2. 当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。314159E-5L(3.14159)
5. 字符常量.字符常量是括在单引号中，例如，'x' 可以存储在 char 类型的简单变量中
6. 字符串常量.字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。您可以使用空格做分隔符，把一个很长的字符串常量进行分行。
7.

```C
// 定义常量
const <数据类型> <变量1> = <必须赋值>;
// 定义常量 #define 预处理器
#define identifier value
```

## 存储类

### auto

auto 存储类是所有**局部变量**默认的存储类。

```c
{
   int mount;
   auto int month;
}
```

### register

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

```c
{
  register int  miles;
}
```

### static

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

### extern

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

## 基本语句组成

- 关键字
- 标识符
- 常量
- 字符串
- 符号

## 预处理

以`#`开头的语句,C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。

```c
#include <stdio.h> ; // 包含一个系统库文件
#include "myheader.h"; // 包含一个自定义头文件
#define	<宏名> <宏值>;//定义宏
#undef	<宏名> ;//取消已定义的宏
#ifdef	<宏名> ;//如果宏已经定义，则返回真
#ifndef	<宏名> ;//如果宏没有定义，则返回真
#if	<宏名> ;//如果给定条件为真，则编译下面代码
#else	//#if 的替代方案
#elif	//如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
#endif	//结束一个 #if……#else 条件编译块
#error	//当遇到标准错误时，输出错误消息
#pragma	//使用标准化方法，向编译器发布特殊的命令到编译器中

// *************预定义宏
__DATE__	当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。
__TIME__	当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。
__FILE__	这会包含当前文件名，一个字符串常量。
__LINE__	这会包含当前行号，一个十进制常量。
__STDC__	当编译器以 ANSI 标准编译时，则定义为 1。

//*********一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。 */
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")
//***********在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")
int main(void)
{
   message_for(Carole, Debra);//Carole and Debra: We love you!
   return 0;
}
/*******标记粘贴运算符（##）
宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。 */
#define tokenpaster(n) printf ("token" #n " = %d", token##n)

int main(void)
{
   int token34 = 40;

   tokenpaster(34);//token34 = 40
   return 0;
}

// 宏定义函数
#define square(x) ((x) * (x))
```

## 头文件

头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。

如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。

## 条件语句

### if

```c
if(布尔表达式){

}else if(布尔表达式){

}else{

}
```

### switch

```c
switch(常量表达式:整型|枚举){
  case 表达式字面量:
  case 表达式字面量:
    [break;] //当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。
  [default:
    ...;]
}
```

### ?:

## 循环语句

### while

```c
while(布尔表达式){

}
```

### for

```c
for(初始化;布尔表达式;更新){

}
```

### do...while

```c
do{

}while(布尔表达式);
```

### 循环控制

```c
break;终止当前循环
continue;跳过此次循环,直接执行下一次循环
goto label;跳到标志位处执行
label: 语句;
```

## 函数

```c
// 入口函数
int main(){
  return 0;
}
// 函数声明;函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。
<返回值类型> <函数名>( [参数列表] );
// 函数定义
<返回值类型> <函数名>( [参数列表] ){
  [函数体];
  return 返回值;
}
// 函数调用
<函数名>( [参数列表] );

```

# 数组

## 定义

```c
// 一维数组声明
<数据类型> <数组名> [ 数组大小 ];
// 初始化
<数据类型> <数组名> [ 数组大小 ] = {value,数目<=数组大小}
<数据类型> <数组名> [ ] = {value,...,数组大小为数目}
// 数组取值下表从0开始
<数组名>[0] = 1;


// 多维数组声明
<数据类型> <数组名> [ 数组大小 ][ 数组大小 ][ 数组大小 ];
```

## 数组与指针

```c
	int a[5] = { 1,2,3,4,5 };
	int* p;
	p = a;
	printf("%d \n", p[0]);//1
	printf("%d \n", *p);//1
	printf("%d \n", *(p+1));//2
	printf("%d \n", *a);//1
	printf("%d \n", *(a+1));//2

数组可以进行指针操作
```

# 指针

## 获取指针

```C
<数据类型> *<变量名> [= NULL];

int a = 1;
// 声明一个指针
int *p;
// 指针指向一个变量
p = &a;
/*
此时: p为a的地址值,*p的值与a相等
*/
```

## 指针运算

## 双指针

## 指针传参

## 函数指针

```c
// 函数指针定义
<返回值类型> (*<指针变量>)(参数列表) = &<函数名>
// 使用,和正常函数使用相同
<指针变量>(参数列表);
// 常见场景 -- 回调函数
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
    for (size_t i=0; i<arraySize; i++)
        array[i] = getNextValue();
}
```

# 字符串

在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束。

```c
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
//等价于
char site[] = "RUNOOB";
```

# 结构体

- 内存对齐: 结构体变量所占内存长度是其中最小字段大小的整数倍

```c
// 定义结构体
struct <结构体名>{
  [<数据类型> <变量名>,]
  [<数据类型> <变量名>,]
  ...
} [结构体变量名1,2,3...];
// 结构体名与结构体变量名至少存在一个
// 定义结构体变量:
struct <结构体名> <结构体变量名1,2,3,...>;

// 结构体表名 typeof
typedef struct
{
    int a;
    char b;
    double c;
} Simple2;
Simple2 <结构体变量名1,2,3,...>;
// 初始化
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book = {"C 语言", "RUNOOB", "编程语言", 123456};
// 访问结构体成员
char *s = book.title;
// 指针访问结构体
struct Books* p;
p = &book;
p->title;
```

# 共用体

- 定义类似于结构体
- 共用体变量所占的内存长度等于最长的成员变量的长度,相较于结构体更节省内存
- 适用场景: 共用体内部的值同一时间只用一个

```c
union [共用体名]{
  <数据类型> 变量1;
  <数据类型> 变量2;
  <数据类型> 变量3;
  ....
}[共用体变量1,2,3,....];

union Data
{
   int i;
   float f;
   char  str[20];
};

// 现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。
int main( )
{
   union Data data;

   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, "C Programming");

   printf( "data.i : %d\n", data.i);//data.i : 1917853763
   printf( "data.f : %f\n", data.f);//data.f : 4122360580327794860452759994368.000000
   printf( "data.str : %s\n", data.str);//data.str : C Programming
   // 共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因

   data.i = 10;
   printf( "data.i : %d\n", data.i);//data.i : 10

   data.f = 220.5;
   printf( "data.f : %f\n", data.f);//data.f : 220.500000

   strcpy( data.str, "C Programming");//data.str : C Programming
   printf( "data.str : %s\n", data.str);
   return 0;
}
```

# 位域

如果程序的结构中包含多个开关量，只有 TRUE/FALSE 变量,在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。

```c
struct 位域结构名
{
  <数据类型> <属性名> : <宽度>;
  ...
  // 数据类型:只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型
  // 宽度,数字,代表变量占据多少 bit 位

} [位域结构变量];

使用与正常的结构体类似,不同的是所占内存大小;
位域内存计算:
1. 位域结构内的属性的属性的数据类型一致时,大小为数据类型大小的倍数
2. 类型不同时,所有位数之和小于最大数据类型大小,内存大小为最大数据类型大小;所有位数之和大于最大数据类型大小,内存大小为最大数据类型大小的倍数;

位域采用相同的数据类型最节省内存.
```

# 类库 stdio.h

[api](https://devdocs.io/c/)

## 标准输入/输出

`stdio.h` 包含标准输入输出函数

1. 文件访问
2.

### 标准

```c
stdin 标准输入--键盘
stdout 标准输出--屏幕
stderr 标准错误--屏幕
```

### format

#### 转义字符

```c
\n //换行
\t // 制表
```

#### 格式字符

```c
%a, %A //以十六进制形式输出浮点数(C99 新增)。
%d	//以十进制形式输出带符号整数(正数不输出符号)
%o	//以八进制形式输出无符号整数(不输出前缀0)
%x,%X	//以十六进制形式输出无符号整数(不输出前缀Ox)
%u	//以十进制形式输出无符号整数
%f	//以小数形式输出单、双精度实数
%e,%E	//以指数形式输出单、双精度实数
%g,%G	//以%f或%e中较短的输出宽度输出单、双精度实数
%c	//输出单个字符
%s	//输出字符串
%p	//输出指针地址
%lu	//32位无符号整数
%llu	//64位无符号整数
```

#### 标识符

```c
-	//在给定的字段宽度内左对齐，默认是右对齐
+	//强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。
空格	//如果没有写入任何符号，则在该值前面插入一个空格。
#	//与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。
0	//在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。
```

#### 宽度

```c
number //要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。
* //宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。
```

#### 精度

```c
.number /*
对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。
对于 e、E 和 f 说明符：要在小数点后输出的小数位数。
对于 g 和 G 说明符：要输出的最大有效位数。
对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。
对于 c 类型：没有任何影响。
当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。
*/
.*	//精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。
```

#### 长度

```c
h	//参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。
l	//参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。
L	//参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。
```

### printf 和 scanf

```c
#include <stdio.h>
// format:  %[标识字符][宽度][精度][长度]格式字符

int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。空格分隔参数

int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。
```

### getchar() & putchar() 函数

单个字符的输入输出

```c
int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。
int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。
```

### gets() & puts() 函数

字符串的输入输出

```c
char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。

int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。
```

### 文件访问

```c
// 打开文件
FILE *fopen( const char *filename, const char *mode );
/*
r	打开一个已有的文本文件，允许读取文件。
w	打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。
a	打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。
r+	打开一个文本文件，允许读写文件。
w+	打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。
a+	打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。
*/
// 关闭文件
int fclose( FILE *fp );
// 写入文件
int fputc( int c, FILE *fp );
int fputs( const char *s, FILE *fp );
// 读取文件
int fgetc( FILE * fp ); // 从头开始读取一个字符
char *fgets( char *buf, int n, FILE *fp ); //读取
```

## 字符串操作 string.h

```c
strcpy(s1, s2);//复制字符串 s2 到字符串 s1。
strcat(s1, s2);//连接字符串 s2 到字符串 s1 的末尾。
unsigned int strlen(s1);//返回字符串 s1 的长度。
strcmp(s1, s2);//如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。
strchr(s1, ch);//返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
strstr(s1, s2);//返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。
```
