## 1. 规则

依赖的关系和执行的命令：

```makefile
targets : prerequisites
    command

#或者
targets : prerequisites; command
    command
```

相关说明如下：

- targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；
- prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；
- command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。

[^1]: 注意：我们的目标和依赖文件之间要使用冒号分隔开，命令的开始一定要使用`Tab`键。

### 1) 显式规则

显式规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。

### 2) 隐晦规则

由于我们的 make 命名有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 命令所支持的。

### 3) 变量的定义

在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像 C 语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。

### 4) 文件指示

其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C 语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译 #if 一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。

### 5) 注释

Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用“#”字符，这个就像 `C/C++`

## 2.工作流程

我们编写 Makefile 的时可以使用的文件的名称 "GNUmakefile" 、"makefile" 、"Makefile" ，make 执行时回去寻找 Makefile 文件，找文件的顺序也是这样的。

​ 一般 Makefile。

使用命令 `make`默认执行第一个目标

## 3.通配符

Makefile 是可以使用 shell 命令的，所以 shell 支持的通配符在 Makefile 中也是同样适用的。 shell 中使用的通配符有："\*"，"?"，"[...]"。

| 通配符 | 使用说明                           |
| ------ | ---------------------------------- |
| \*     | 匹配 0 个或者是任意个字符          |
| ？     | 匹配任意一个字符                   |
| []     | 我们可以指定匹配的字符放在 "[]" 中 |

通配符作为变量、参数时要用`wildcard`函数展开。

```makefile
OBJ=$(wildcard *.c)
test:$(OBJ)
    gcc -o $@ $^
```

还有一个和通配符 "\*" 相类似的字符，这个字符是 "%"，也是匹配任意个字符，使用在我们的的规则当中。

```makefile
test:test.o test1.o
​    gcc -o $@ $^
%.o:%.c
​    gcc -o $@ $^
# "%.o" 把我们需要的所有的 ".o" 文件组合成为一个列表，从列表中挨个取出的每一个文件，"%" 表示取出来文件的文件名（不包含后缀），然后找到文件中和 "%"名称相同的 ".c" 文件，然后执行下面的命令，直到列表中的文件全部被取出来为止。

```

这个属于 Makefile 中静态模规则：规则存在多个目标，并且不同的目标可以根据目标文件的名字来自动构造出依赖文件。跟我们的多规则目标的意思相近，但是又不相同。

## 4.变量

### 4.1 变量的定义

Makefile 文件中定义变量的基本语法如下：

```
变量的名称=值列表
```

变量的名称可以由大小写字母、阿拉伯数字和下划线构成

值列表，既可以是零项，又可以是一项或者是多项。

调用变量的时候可以用 "$(VALUE_LIST)" 或者是 "${VALUE_LIST}" 来替换，这就是变量的引用。

### 4.2 变量的基本赋值

知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：

- 简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
- 递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
- 条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。
- 追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。

### 4.3 自动化变量

| 自动化变量 | 说明                                                                                                                                                                                                                   |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| $@         | 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。                            |
| $%         | 当目标文件是一个静态库文件时，代表静态库的一个成员名。                                                                                                                                                                 |
| $<         | 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。                                                                                                             |
| $?         | 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。                                                                                                                      |
| $^         | 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件。 |
| $+         | 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。                                                                                                                                   |
| $\*        | 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。                                                                                                   |

GNU make 中在这些变量中加入字符 "D" 或者 "F" 就形成了一系列变种的自动化变量，这些自动化变量可以对文件的名称进行操作。
下面是一些详细的描述：

| 变量名      | 功能                                                                                                                                                       |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| $(@D)       | 表示文件的目录部分（不包括斜杠）。如果 "$@" 表示的是 "dir/foo.o" 那么 "$(@D)" 表示的值就是 "dir"。如果 "$@" 不存在斜杠（文件在当前目录下），其值就是 "."。 |
| $(@F)       | 表示的是文件除目录外的部分（实际的文件名）。如果 "$@" 表示的是 "dir/foo.o"，那么 "$@F" 表示的值为 "dir"。                                                  |
| $(*D) $(*F) | 分别代表 "茎" 中的目录部分和文件名部分                                                                                                                     |
| $(%D) $(%F) | 当以 "archive(member)" 形式静态库为目标时，分别表示库文件成员 "member" 名中的目录部分和文件名部分。踏进对这种新型时的目标有效。                            |
| $(<D) $(<F) | 表示第一个依赖文件的目录部分和文件名部分。                                                                                                                 |
| $(^D) $(^F) | 分别表示所有依赖文件的目录部分和文件部分。                                                                                                                 |
| $(+D) $(+F) | 分别表示所有的依赖文件的目录部分和文件部分。                                                                                                               |
| $(?D) $(?F) | 分别表示更新的依赖文件的目录部分和文件名部分。                                                                                                             |

### 4.4 变量的替换引用

我们定义变量的目的是为了简化我们的书写格式，代替我们在代码中频繁出现且冗杂的部分。它可以出现在我们规则的目标中，也可以是我们规则的依赖中。我们使用的时候会经常的对它的值（表示的字符串）进行操作。遇到这样的问题我们可能会想到我们的字符串操作函数，比如 "patsubst" 就是我们经常使用的。但是我们使用变量同样可以解决这样的问题，我们通过下面的例子来具体的分析一下。

```
foo:=a.c b.c d.c
obj:=$(foo:.c=.o)
All:
    @echo $(obj)
```

这段代码实现的功能是字符串的后缀名的替换，把变量 foo 中所有的以 .c 结尾的字符串全部替换成 .o 结尾的字符串。我们在 Makefile 中这样写，然后再 shell 命令行执行 make 命令，就可以看到打印出来的是 "a.o b.o d.o" ，实现了文件名后缀的替换。

[^6]: 注意：括号中的变量使用的是变量名而不是变量名的引用，变量名的后面要使用冒号和参数选项分开，表达式中间不能使用空格。第二个变量 obj 是对整体的引用。

上面的例子我们可以换一种更加通用的方式来写，代码展示如下：

```
foo:=a.c b.c d.c
obj:=$(foo:%.c=%.o)
All:
    @echo $(obj)
```

我们在 shell 中执行 make 命令，发现结果是相同的。

对比上面的实例我们可以看到，表达式中使用了 "%" 这个字符，这个字符的含义就是自动匹配一个或多个字符。在开发的过程中，我们通常会使用这种方式来进行变量替换引用的操作。

为什么这种方式比第一种方式更加实用呢？我们在实际使用的过程中，我们对变量值的操作不只是修改其中的一个部分，甚至是改变其中的多个，那么第一种方式就不能实现了。我们来看一下这种情况：

```
foo:=a123c a1234c a12345c
obj:=$(foo:a%c=x%y)
All:
    @echo $(obj)
```

我们可以看到这个例子中我们操作的是两个不连续的部分，我们执行 make 后打印的值是 "x123y x1234y x12345y"，这种情况下我们使用第一种情况就不能实现，所以第二种的使用更全面。

### 4.5 变量的嵌套使用

变量的嵌套引用的具体含义是这样的，我们可以在一个变量的赋值中引用其他的变量，并且引用变量的数量和和次数是不限制的。下面我们通过几个实例来说明一下。

```makefile
#实例 1：变量的嵌套使用
foo:=test
var:=$(foo)
All:
    @echo $(var)
#实例 2
foo=bar
var=test
var:=$($(foo))
All:
    @echo $(var)
 #实例 3
first_pass=hello
bar=first
var:=$(bar)_pass
all:
    @echo $(var)
# 实例 4
first_pass=hello
bar=first
foo=pass
var:=$(bar)_$(foo)
all:
    @echo $(var)
```

变量的嵌套引用和我们的变量的递归赋值的区别：嵌套引用的使用方法就是用一个变量表示另外一个变量，然后进行多层的引用。而递归展开的变量表示当一个变量存在对其它变量的引用时，对这变量替换的方式。递归展开在另外一个角度描述了这个变量在定义是赋予它的一个属性或者风格。并且我们可以在定义个一个递归展开式的变量时使用套嵌引用的方式，但是建议你的实际编写 Makefile 时要尽量避免这种复杂的用法。

在实际使用的过程中变量的第一种用法经常使用的，第二种用法我们很少使用，应该说是尽量避免使用变量的嵌套引用。在必须要使用的时候我们应该做到嵌套的层数是越少越好的。因为使用这种方法表达会比较的复杂，如果条理不清楚的话我们就会出错。并且在给其他人看的时候也会不容易理解。

## 5. 目标文件搜索

常见的搜索的方法的主要有两种：一般搜索`VPATH`和选择搜索`vpath`。

VPATH 和 vpath 的区别：VPATH 是变量，更具体的说是环境变量，Makefile 中的一种特殊变量，使用时需要指定文件的路径；vpath 是关键字，按照模式搜索，也可以说成是选择搜索。搜索的时候不仅需要加上文件的路径，还需要加上相应限制的条件。

```makefile
VPATH := src
VPATH := src car
VPATH := src:car
```

[^2]: 注意：无论你定义了多少路径，make 执行的时候会先搜索当前路径下的文件，当前目录下没有我们要找的文件，才去 VPATH 的路径中去寻找。如果当前目录下有我们要使用的文件，那么 make 就会使用我们当前目录下的文件。

```makefile
vpath PATTERN DIRECTORIES #在 src 路径下搜索文件 test.c
vpath PATTERN  #用法二的意思是清除符合文件 test.c 的搜索目录。
vpath #vpath 单独使的意思是清除所有已被设置的文件搜索路径
```

( PATTERN：可以理解为要寻找的条件，DIRECTORIES：寻找的路径 )

## 6. Makefile 隐含规则

这个章节讲述的是 Makefile 的隐含规则，所谓的隐含规则就是需要我们做出具体的操作，系统自动完成。

编写 Makefile 的时候，可以使用隐含规则来简化 Makefile 文件编写。
实例：

```
test:test.o
    gcc -o test test.o
test.o:test.c
```

我们可以在 Makefile 中这样写来编译 test.c 源文件，相比较之前少写了重建 test.o 的命令。但是执行 make，发现依然重建了 test 和 test.o 文件，运行结果却没有改变。这其实就是隐含规则的作用。

在某些时候其实不需要给出重建目标文件的命令，有的甚至可以不需要给出规则。实例：

```
test:test.o
    gcc -o test test.o
```

运行的结果是相同的。

隐含规则的具体的工作流程：make 执行过程中找到的隐含规则，提供了此目标的基本依赖关系。确定目标的依赖文件和重建目标需要使用的命令行。隐含规则所提供的依赖文件只是一个基本的（在 C 语言中，通常他们之间的对应关系是：test.o 对应的是 test.c 文件）。当需要增加这个文件的依赖文件的时候要在 Makefile 中使用没有命令行的规则给出。

实例：

```
test:test.o
    gcc -o test test.o
test:test1.h
```

其实在有些时候隐含规则的使用会出现问题。因为有一个 make 的“隐含规则库”。库中的每一条隐含规则都有相应的优先级顺序，优先级也就会越高，使用时也就会被优先使用。

```
foo.o:foo.p
```

我们都知道 .p 文件是 Pascal 程序的源文件，如果书写规则时不加入命令的话，那么 make 会按照隐含的规则来重建目标文件 foo.o。如果当前目录下恰好存在 foo.c 文件的时候，隐含规则会把 foo.c 当做是 foo.o 的依赖文件进行目标文件的重建。因为编译 .c 文件的隐含规则在编译 .p 文件之前，显然优先级也会越高。当 make 找到生成 foo.o 的文件之后，就不会再去寻找下一条规则。如果我们不想使用隐含规则，在使用的时候不仅要声明规则，也要添加上执行的命令。

这里讲的是预先设置的隐含规则。如果不明确的写下规则，那么 make 就会自己寻找所需要的规则和命令。当然我们也可以使用 make 选项：`-r`或`-n-builtin-rules`选项来取消所有的预设值的隐含规则。当然即使是指定了“-r”的参数，某些隐含规则还是会生效。因为有很多的隐含规则都是使用了后缀名的规则来定义的，所以只要隐含规则中含有“后缀列表”那么隐含规则就会生效。默认的列表是：

```
.out、.a、.in、.o、.c、.cc、.C、.p、.f、.F、.r、.y、.l、.s、.S、.mod、.sym、.def、
.h、.info、.dvi、.tex、.texinfo、.texi、.txinfo、.w、.ch、.web、.sh、.elc、.el。
```

下面是一些常用的隐含规则：

```
编译 C 程序
编译 [C++](http://c.biancheng.net/cplus/) 程序
编译 Pascal 程序
编译 Fortran/Ratfor 程序
预处理 Fortran/Ratfor 程序
编译 Modula-2 程序
汇编和需要预处理的汇编程序
链接单一的 object 文件
Yacc C 程序
Lex C 程序时的隐含规则
```

内嵌隐含规则的命令中，所使用的变量都是预定义的。我们将这些变量称为“隐含变量”。这些变量允许修改：可以通过命令行参数传递或者是设置系统环境变量的方式都可以对它进行重新定义。无论使用哪种方式，只要 make 在运行的，这些变量的定义有效。Makefile 的隐含规则都会使用到这些变量。

隐含规则中使用的变量可以分成两类：

1.代表一个程序的名字。例如：“CC”代表了编译器的这个可执行程序。

2.代表执行这个程序使用的参数.例如：变量“CFLAGS”。多个参数之间使用空格隔开。

- AR：函数库打包程序，科创价静态库 .a 文档。
- AS：应用于汇编程序。
- CC：C 编译程序。
- CXX：C++编译程序。
- CO：从 RCS 中提取文件的程序。
- CPP：C 程序的预处理器。
- FC：编译器和与处理函数 Fortran 源文件的编译器。
- GET：从 CSSC 中提取文件程序。
- LEX：将 Lex 语言转变为 C 或 Ratfo 的程序。
- PC：Pascal 语言编译器。
- YACC：Yacc 文法分析器（针对于 C 语言）
- YACCR：Yacc 文法分析器。

## 7. 条件判断

需要解决的问题：要根据判断，分条件执行语句。
条件语句的作用：条件语句可以根据一个变量的值来控制 make 执行或者时忽略 Makefile 的特定部分，条件语句可以是两个不同的变量或者是常量和变量之间的比较。

条件语句使用优点：Makefile 中使用条件控制可以做到处理的灵活性和高效性。

[^3]: 注意：条件语句只能用于控制 make 实际执行的 Makefile 文件部分，不能控制规则的 shell 命令执行的过程。

| 关键字 | 功能                                              |
| ------ | ------------------------------------------------- |
| ifeq   | 判断参数是否不相等，相等为 true，不相等为 false。 |
| ifneq  | 判断参数是否不相等，不相等为 true，相等为 false。 |
| ifdef  | 判断是否有值，有值为 true，没有值为 false。       |
| ifndef | 判断是否有值，没有值为 true，有值为 false。       |

条件语句中使用到三个关键字“ifeq”、“else”、“endif”。其中：“ifeq”表示条件语句的开始，并指定一个比较条件（相等）。括号和关键字之间要使用空格分隔，两个参数之间要使用逗号分隔。参数中的变量引用在进行变量值比较的时候被展开。“ifeq”，后面的是条件满足的时候执行的，条件不满足忽略；“else”表示当条件不满足的时候执行的部分，不是所有的条件语句都要执行此部分；“endif”是判断语句结束标志，Makefile 中条件判断的结束都要有。

## 8. 伪目标

所谓的伪目标可以这样来理解，它并不会创建目标文件，只是想去执行这个目标下面的命令。伪目标的存在可以帮助我们找到命令并执行。

使用伪目标有两点原因：

- 避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。
- 提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。

将一个目标声明称伪目标的方法是将它作为特殊的目标`.PHONY`的依赖，如下：

```makefile
.PHONY:clean
```

这样 clean 就被声明成一个伪目标，无论当前目录下是否存在 clean 这个文件，当我们执行 make clean 后 rm 都会被执行。而且当一个目标被声明为伪目标之后，make 在执行此规则时不会去试图去查找隐含的关系去创建它。这样同样提高了 make 的执行效率，同时也不用担心目标和文件名重名而使我们的编译失败。

## 9. 字符串处理函数

函数的语法结构。函数的调用和变量的调用很像。引用变量的格式为`$(变量名)`

```makefile
$(<function> <arguments>)    或者是     ${<function> <arguments>}
```

其中，function 是函数名，arguments 是函数的参数，参数之间要用逗号分隔开。而参数和函数名之间使用空格分开。调用函数的时候要使用字符“$”，后面可以跟小括号也可以使用花括号。

### 9.1 模式字符串替换函数

```makefile
$(patsubst <pattern>,<replacement>,<text>)
#函数说明：函数功能是查找 text 中的单词是否符合模式 pattern，如果匹配的话，则用 replacement 替换。返回值为替换后的新字符串。
```

### 9.2 字符串替换函数

```makefile
$(subst <from>,<to>,<text>)
#函数说明：函数的功能是把字符串中的 form 替换成 to，返回值为替换后的新字符串
```

### 9.3 去空格函数

```Makefile
$(strip <string>)
#函数说明：函数的功能是去掉字符串的开头和结尾的字符串，并且将其中的多个连续的空格合并成为一个空格。返回值为去掉空格后的字符串。
```

### 9.4 查找字符串函数

```makefile
$(findstring <find>,<in>)
#函数说明：函数的功能是查找  in 中的 find ,如果我们查找的目标字符串存在。返回值为目标字符串，如果不存在就返回空。
```

### 9.5 过滤函数

```makefile
$(filter <pattern>,<text>)
#函数说明：函数的功能是过滤出 text 中符合模式 pattern 的字符串，可以有多个 pattern 。返回值为过滤后的字符串。
```

### 9.6 反过滤函数

```makefile
$(filter-out <pattern>,<text>)
#函数说明：函数的功能是功能和 filter 函数正好相反，但是用法相同。去除符合模式  pattern 的字符串，保留符合的字符串。返回值是保留的字符串。
```

### 9.7 排序函数

```makefile
$(sort <list>)
#函数说明：函数的功能是将 <list>中的单词排序（升序）。
```

## 10.常用文件名操作函数

**取目录函数**

```
$(dir <names>)
函数说明：函数的功能是从文件名序列 names 中取出目录部分，如果没有 names 中没有 "/" ，取出的值为 "./" 。返回值为目录部分，指的是最后一个反斜杠之前的部分。如果没有反斜杠将返回“./”。
```

**取文件函数**

```
$(notdir <names>)
函数说明：函数的功能是从文件名序列 names 中取出非目录的部分。非目录的部分是最后一个反斜杠之后的部分。返回值为文件非目录的部分。
```

**取后缀名函数**

```
$(suffix <names>)
函数说明：函数的功能是从文件名序列中 names 中取出各个文件的后缀名。返回值为文件名序列 names 中的后缀序列，如果文件没有后缀名，则返回空字符串。
```

**取前缀函数**

```
$(basename <names>)
函数说明：函数的功能是从文件名序列 names 中取出各个文件名的前缀部分。返回值为被取出来的文件的前缀名，如果文件没有前缀名则返回空的字符串。
```

**添加后缀名函数**

```
$(addsuffix <suffix>,<names>)
函数说明：函数的功能是把后缀 suffix 加到 names 中的每个单词后面。返回值为添加上后缀的文件名序列。
```

**添加前缀名函数**

```
$(addperfix <prefix>,<names>)
函数说明：函数的功能是把前缀 prefix 加到 names 中的每个单词的前面。返回值为添加上前缀的文件名序列。
```

**链接函数**

```
$(join <list1>,<list2>)
函数说明：函数功能是把 list2 中的单词对应的拼接到 list1 的后面。如果 list1 的单词要比 list2的多，那么，list1 中多出来的单词将保持原样，如果 list1 中的单词要比 list2 中的单词少，那么 list2 中多出来的单词将保持原样。返回值为拼接好的字符串。
```

**获取匹配模式文件名函数**

```
$(wildcard PATTERN)
函数说明：函数的功能是列出当前目录下所有符合模式的 PATTERN 格式的文件名。返回值为空格分隔并且存在当前目录下的所有符合模式 PATTERN 的文件名。
```

## 11. 其它常用函数

```makefile
$(foreach <var>,<list>,<text>)
#函数的功能是：把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的返所返回的每个字符串会以空格分割，最后当整个循环结束的时候，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。所以<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会只用<var>这个参数来一次枚举<list>中的单词。
#注意，foreach 中的 <var> 参数是一个临时的局部变量，foreach 函数执行完后，参数<var>的变量将不再作用，其作用域只在 foreach 函数当中。

$(if <condition>,<then-part>)或(if<condition>,<then-part>,<else-part>)
#可见，if 函数可以包含else部分，或者是不包含，即if函数的参数可以是两个，也可以是三个。condition参数是 if 表达式，如果其返回的是非空的字符串，那么这个表达式就相当于返回真，于是，then-part就会被计算，否则else-part会被计算。
#而if函数的返回值是：如果condition为真（非空字符串），那么then-part会是整个函数的返回值。如果condition为假（空字符串），那么else-part将会是这个函数的返回值。此时如果else-part没有被定义，那么整个函数返回空字串符。所以，then-part和else-part只会有一个被计算。

$(call <expression>,<parm1>,<parm2>,<parm3>,...)
#call 函数是唯一一个可以用来创建新的参数化的函数。我们可以用来写一个非常复杂的表达式，这个表达式中，我们可以定义很多的参数，然后你可以用 call 函数来向这个表达式传递参数。
#当 make 执行这个函数的时候，expression参数中的变量$(1)、$(2)、$(3)等，会被参数parm1，parm2，parm3依次取代。而expression的返回值就是 call 函数的返回值。

$(origin <variable>)
#origin 函数不像其他的函数，它并不操作变量的值，它只是告诉你这个变量是哪里来的。
#注意： variable 是变量的名字，不应该是引用，所以最好不要在 variable 中使用“$”字符。origin 函数会员其返回值来告诉你这个变量的“出生情况”。
#下面是origin函数返回值：
“undefined”：如果<variable>从来没有定义过，函数将返回这个值。
“default”：如果<variable>是一个默认的定义，比如说“CC”这个变量。
“environment”：如果<variable>是一个环境变量并且当Makefile被执行的时候，“-e”参数没有被打开。
“file”：如果<variable>这个变量被定义在Makefile中，将会返回这个值。
“command line”：如果<variable>这个变量是被命令执行的，将会被返回。
“override”：如果<variable>是被override指示符重新定义的。
“automatic”：如果<variable>是一个命令运行中的自动化变量。
```

## 12. 命令的编写

Makefile 的规则是什么，他是由依赖关系规则和命令组成的。所使用的命令是由 shell 命令行组成，他们是一条一条执行的。多个命令之间要使用分号隔开，Makefile 中的任何命令都要以`tab`键开始。多个命令行之间可以有空行和注释行，在执行规则时空行会被自动忽略。

​ 通常系统中可能存在不同的 shell 。但是 make 处理 Makefile 过程时，如果没有明确的指定，那么对所有规则中的命令行的解析使用`bin/sh`来完成。执行过程中使用的 shell 决定了规则中的命令的语法和处理机制。当使用默认的`bin/sh`时，命令中出现的字符“#”到行末的内容被认为是注释。当然了“#”可以不在此行的行首，此时“#”之前的内容不会被作为注释处理。

### 12.1 命令回显

通常 make 在执行命令行之前会把要是执行的命令行输出到标准输出设备。我们称之为 "回显"，就好像我们在 shell 环境下输入命令执行时一样。如果规则的命令行以字符“@”开始，则 make 在执行的时候就不会显示这个将要被执行的命令。典型的用法是在使用`echo`

我们在执行 make 时添加上一些参数，可以控制命令行是否输出。当使用 make 的时候机加上参数`-n`或者是`--just-print` ，执行时只显示所要执行的命令，但不会真正的执行这个命令。只有在这种情况下 make 才会打印出所有的 make 需要执行的命令，其中包括了使用的“@”字符开始的命令。这个选项对于我们调试 Makefile 非常的有用，使用这个选项就可以按执行顺序打印出 Makefile 中所需要执行的所有命令。而 make 参数`-s`或者是`--slient`则是禁止所有的执行命令的显示。就好像所有的命令行都使用“@”开始一样。

### 12.2 命令的执行

当规则中的目标需要被重建的时候，此规则所定义的命令将会被执行，如果是多行的命令，那么每一行命令将是在一个独立的子 shell 进程中被执行。因此，多命令行之间的执行命令时是相互独立的，相互之间不存在以来。
在 Makefile 中书写在同一行中的多个命令属于一个完整的 shell 命令行，书写在独立行的一条命令是一个独立的 shell 命令行。因此：在一个规则的命令中命令行 “cd”改变目录不会对其后面的命令的执行产生影响。就是说之后的命令执行的工作目录不会是之前使用“cd”进入的那个目录。如果达到这个目的，就不能把“cd”和其后面的命令放在两行来书写。而应该把这两个命令放在一行上用分号隔开。这样才是一个完整的 shell 命令行。

如果想把一个完整的 shell 命令行书写在多行上，需要使用反斜杠 (\)来对处于多行的命令进行连接，表示他们是一个完整的 shell 命令行。

```
foo:bar.lose
    cd bar; \
    gobble lose > ../foo
```

make 对所有规则的命令的解析使用环境变量“SHELL”所指定的那个程序。在 GNU make 中，默认的程序时 “/bin/sh”。不像其他的绝大多数变量，他们的只可以直接从同名的系统环境变量那里获得。make 的环境变量 “SHELL”没有使用环境变量的定义。因为系统环境变量“SHELL”指定的那个程序被用来作为用户和系统交互的接口程序，他对于不存在直接交互过程的 make 显然不合适。在 make 环境变量中“SHELL”会被重新赋值；他作为一个变量我们也可以在 Makefile 中明确的给它赋值，变量“SHELL“的默认值时“/bin/sh”。

### 12.3 并发执行命令

GNU make 支持同时执行多条命令。通常情况下，同一时刻只有一个命令在执行，下一个命令只有在当前命令结束之后才能够开始执行。不过可以通过 make 命令行选项 "-j" 或者 "--jobs" 来告诉 make 在同一时刻可以允许多条命令同时执行。
如果选项 "-j" 之后存在一个整数，其含义是告诉 make 在同一时刻可以允许同时执行的命令行的数目。这个数字被称为。当 "-j" 选项中没有出现数字的时候，那么同一时间执行的命令数目没有要求。使用默认的，值为 1，表示 make 将串行的执行规则的命令（同一时刻只能由一条命令被执行）。

- 多个同时执行的命令的输出信息将同时被输出到终端。当出现错误时很难根据一大堆凌乱的信息来区分那条命令执行错误。
- 在同一时刻可能会存在多个命令执行的进程同时读取到标准输入，但是对于白哦准输入设备来说，在同一时刻只能存在一个进程访问它。就是说在某个时间点，make 只能保证此刻正在执行的进程中的一个进程读取标准输入流。而其他的进程键的标准输入流将设置为无效。因此在此一时刻多个执行命令的进程中只有一个进程获得标准输入，而其他的需要读取标准输入流的进程由于输入流无效而导致致命的错误。

## 13. include 文件包含

当 make 读取到 "include" 关键字的时候，会暂停读取当前的 Makefile，而是去读 "include" 包含的文件，读取结束后再继读取当前的 Makefile 文件。"include" 使用的具体方式如下：

```
include <filenames>
```

filenames 是 shell 支持的文件名（可以使用通配符表示的文件）。

[^3]: 注意："include" 关键字所在的行首可以包含一个或者是多个的空格（读取的时候空格会被自动的忽略），但是不能使用 Tab 开始，否则会把 "include" 当作式命令来处理。包含的多个文件之间要使用空格分隔开。使用 "include" 包含进来的 Makefile 文件中，如果存在函数或者是变量的引用，它们会在包含的 Makefile 中展开。

如果在上面的路径没有找到 "include" 指定的文件，make 将会提示一个文件没有找到的警示提示，但是不会退出，而是继续执行 Makefile 的后续的内容。当完成读取整个 Makefile 后，make 将试图使用规则来创建通过 "include" 指定但不存在的文件。当不能创建的时候，文件将会保存退出。

使用时，通常用 "-include" 来代替 "include" 来忽略文件不存在或者是无法创建的错误提示，使用格式如下：

```
-include <filename>
```

这两种方式之间的区别：

- 使用 `include <filenames>` ，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。
- 使用 `-include <filenames>`，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。

## 14. 嵌套执行 make

```
subsystem:
    cd subdir && $(MAKE)
```

这个例子可以这样来理解，在当前目录下有一个目录文件 subdir 和一个 Makefile 文件，子目录 subdir 文件下还有一个 Makefile 文件，这个文件是用来描述这个子目录文件的编译规则。使用时只需要在最外层的目录中执行 make 命令，当命令执行到上述的规则时，程序会进入到子目录中执行 make。这就是嵌套执行 make，我们把最外层的 Makefile 称为是总控 Makefile。

上述的规则也可以换成另外一种写法：

```makefile
subsystem
    $(MAKE) -C subdir
```

在 make 的嵌套执行中，我们需要了解一个变量 "CURDIR"，此变量代表 make 的工作目录。当使用 make 的选项 "-C" 的时候，命令就会进入指定的目录中，然后此变量就会被重新赋值。总之，如果在 Makefile 中没有对此变量进行显式的赋值操作，那么它就表示 make 的工作目录。我们也可以在 Makefile 中为这个变量赋一个新的值，当然重新赋值后这个变量将不再代表 make 的工作目录。

**export 的使用**

使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：

```
export <variable>
```

如果不需要那么可以这样来写：

```
unexport <variable>
```

`<variable>`是变量的名字，不需要使用 "$" 这个字符。如果所有的变量都需要传递，那么只需要使用 "export" 就可以，不需要添加变量的名字。

Makefile 中还有两个变量不管是不是使用关键字 "export" 声明，它们总会传递到下层的 Makefile 中。这两个变量分别是 SHELL 和 MAKEFLAGS，特别是 MAKEFLAGS 变量，包含了 make 的参数信息。如果执行总控 Makefile 时，make 命令带有参数或者在上层的 Makefile 中定义了这个变量，那么 MAKEFLAGS 变量的值将会是 make 命令传递的参数，并且会传递到下层的 Makefile 中，这是一个系统级别的环境变量。

make 命令中有几个参数选项并不传递，它们是:"-C"、"-f"、"-o"、"-h" 和 "-W"。如果我们不想传递 MAKEFLAGS 变量的值，在 Makefile 中可以这样来写：

## 15. 命令参数和选项大汇总

| 参数选项                                                       | 功能                                                                                                                                                                                                                                  |
| -------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -b，-m                                                         | 忽略，提供其他版本 make 的兼容性                                                                                                                                                                                                      |
| -B，--always-make                                              | 强制重建所有的规则目标，不根据规则的依赖描述决定是否重建目标文件。                                                                                                                                                                    |
| -C DIR，--directory=DIR                                        | 在读取 Makefile 之前，进入到目录 DIR，然后执行 make。当存在多个 "-C" 选项的时候，make 的最终工作目录是第一个目录的相对路径。                                                                                                          |
| -d                                                             | make 在执行的过程中打印出所有的调试信息，包括 make 认为那些文件需要重建，那些文件需要比较最后的修改时间、比较的结果，重建目标是用的命令，遗憾规则等等。使用 "-d" 选项我们可以看到 make 构造依赖关系链、重建目标过程中的所有的信息。   |
| --debug[=OPTIONS]                                              | make 执行时输出调试信息，可以使用 "OPTIONS" 控制调试信息的级别。默认是 "OPTIONS=b" ，"OPTIONS" 的可值为以下这些，首字母有效：all、basic、verbose、implicit、jobs、makefile。                                                          |
| -e，--enveronment -overrides                                   | 使用环境变量定义覆盖 Makefile 中的同名变量定义。                                                                                                                                                                                      |
| -f=FILE，--file=FILE， --makefile=FILE                         | 指定文件 "FILE" 为 make 执行的 Makefile 文件                                                                                                                                                                                          |
| -p，--help                                                     | 打印帮助信息。                                                                                                                                                                                                                        |
| -i，--ignore-errors                                            | 执行过程中忽略规则命令执行的错误。                                                                                                                                                                                                    |
| -I DIR，--include-dir=DIR                                      | 指定包含 Makefile 文件的搜索目录，在 Makefile 中出现另一个 "include" 文件时，将在 "DIR" 目录下搜索。多个 "-i" 指定目录时，搜索目录按照指定的顺序进行。                                                                                |
| -j [JOBS]，--jobs[=JOBS]                                       | 可指定同时执行的命令数目，爱没有 "-j" 的情况下，执行的命令数目将是系统允许的最大可能数目，存在多个 "-j" 目标时，最后一个目标指定的 JOBS 数有效。                                                                                      |
| -k，--keep-going                                               | 执行命令错误时不终止 make 的执行，make 尽最大可能执行所有的命令，直至出现知名的错误才终止。                                                                                                                                           |
| -l load，--load-average=[=LOAD]，--max-load[=LOAD]             | 告诉 make 在存在其他任务执行的时候，如果系统负荷超过 "LOAD"，不在启动新的任务。如果没有指定 "LOAD" 的参数 "-l" 选项将取消之前 "-l" 指定的限制。                                                                                       |
| -n，--just-print，--dry-run                                    | 只打印执行的命令，但是不执行命令。                                                                                                                                                                                                    |
| -o FILE，--old-file=FILE， --assume-old=FILE                   | 指定 "FILE"文件不需要重建，即使是它的依赖已经过期；同时不重建此依赖文件的任何目标。注意：此参数不会通过变量 "MAKEFLAGS" 传递给子目录进程。                                                                                            |
| -p，--print-date-base                                          | 命令执行之前，打印出 make 读取的 Makefile 的所有数据，同时打印出 make 的版本信息。如果只需要打印这些数据信息，可以使用 "make -qp" 命令，查看 make 执行之前预设的规则和变量，可使用命令 "make -p -f /dev/null"                         |
| -q，-question                                                  | 称为 "询问模式" ；不运行任何的命令，并且无输出。make 只返回一个查询状态。返回状态 0 表示没有目标表示重建，返回状态 1 表示存在需要重建的目标，返回状态 2 表示有错误发生。                                                              |
| -r，--no-builtin-rules                                         | 取消所有的内嵌函数的规则，不过你可以在 Makefile 中使用模式规则来定义规则。同时选项 "-r" 会取消所有后缀规则的隐含后缀列表，同样我们可以在 Makefile 中使用 ".SUFFIXES"，定义我们的后缀名的规则。"-r" 选项不会取消 make 内嵌的隐含变量。 |
| -R，--no-builtin-variabes                                      | 取消 make 内嵌的隐含变量，不过我们可以在 Makefile 中明确定义某些变量。注意："-R" 和 "-r" 选项同时打开，因为没有了隐含变量，所以隐含规则将失去意义。                                                                                   |
| -s，--silent，--quiet                                          | 取消命令执行过程中的打印。                                                                                                                                                                                                            |
| -S，--no-keep-going， --stop                                   | 取消 "-k" 的选项在递归的 make 过程中子 make 通过 "MAKEFLAGS" 变量继承了上层的命令行选项那个。我们可以在子 make 中使用“-S”选项取消上层传递的 "-k" 选项，或者取消系统环境变量 "MAKEFLAGS" 中 "-k"选项。                                 |
| -t，--touch                                                    | 和 Linux 的 touch 命令实现功能相同，更新所有的目标文件的时间戳到当前系统时间。防止 make 对所有过时目标文件的重建。                                                                                                                    |
| -v，version                                                    | 查看 make 的版本信息。                                                                                                                                                                                                                |
| -w，--print-directory                                          | 在 make 进入一个子目录读取 Makefile 之前打印工作目录，这个选项可以帮助我们调试 Makefile，跟踪定位错误。使用 "-C" 选项时默认打开这个选项。                                                                                             |
| --no-print-directory                                           | 取消 "-w" 选项。可以是 用在递归的 make 调用的过程中 ，取消 "-C" 参数的默认打开 "-w" 的功能。                                                                                                                                          |
| -W FILE，--what-if=FILE， --new-file=FILE， --assume-file=FILE | 设定文件 "FILE" 的时间戳为当前的时间，但不更改文件实际的最后修改时间。此选项主要是为了实现对所有依赖于文件 "FILE" 的目标的强制重建。                                                                                                  |
| --warn-undefined-variables                                     | 在发现 Makefile 中存在没有定义的变量进行引用时给出告警信息。此功能可以帮助我们在调试一个存在多级嵌套变量引用的复杂 Makefile。但是建议在书写的时候尽量避免超过三级以上的变量嵌套引用。                                                 |

## 16.目标类型大汇总

### 16.1 强制目标

如果一个目标中没有命令或者是依赖，并且它的目标不是一个存在的文件名，在执行此规则时，目标总会被认为是最新的。就是说：这个规则一旦被执行，make 就认为它的目标已经被更新过。这样的目标在作为一个规则的依赖时，因为依赖总被认为更新过，因此作为依赖在的规则中定义的命令总会被执行。

```
clean:FORCE
    rm $(OBJECTS)
FORCE:
```

这个例子中，目标 "FORCE" 符合上边的条件。它作为目标 "clean" 的依赖，在执行 make 的时候，总被认为更新过。因此 "clean" 所在的规则而在被执行其所定义的那个命令总会被执行。这样的一个目标通常我们将其命名为 "FORCE"。

### 16.2 空目标文件

空目标文件是伪目标的一个变种，此目标所在的规则执行的目的和伪目标相同——通过 make 命令行指定将其作为终极目标来执行此规则所定义的命令。和伪目标不同的是：这个目标可以是一个存在的文件，但文件的具体内容我们并不关心，通常此文件是一个空文件。
空目标文件只是用来记录上一次执行的此规则的命令的时间。在这样的规则中，命令部分都会使用 "touch" 在完成所有的命令之后来更新目标文件的时间戳，记录此规则命令的最后执行时间。make 时通过命令行将此目标作为终极目标，当前目标下如果不存在这个文件，"touch" 会在第一次执行时创建一个的文件。

```
print:foot.c bar.c
    lpr -p $?
    touch print
```

执行 "make print" ,当目标文件 "print" 的依赖文件被修改之后，命令 "lpr -p $?" 都会被执行，打印这个被修改的文件。

### 16.3 特殊的目标

| 名称                   | 功能                                                                                                                                                                                                                     |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| .PHONY:                | 这个目标的所有依赖被作为伪目标。伪目标是这样一个目标：当使用 make 命令行指定此目标时，这个目标所在的规则定义的命令、无论目标文件是否存在都会被无条件执行。                                                               |
| .SUFFIXES:             | 这个目标的所有依赖指出了一系列在后缀规则中需要检查的后缀名                                                                                                                                                               |
| .DEFAULT:              | Makefile 中，这个特殊目标所在规则定义的命令，被用在重建那些没有具体规则的目标，就是说一个文件作为某个规则的依赖，却不是另外一个规则的目标时，make 程序无法找到重建此文件的规则，这种情况就执行 ".DEFAULT" 所指定的命令。 |
| .PRECIOUS:             | 这个特殊目标所在的依赖文件在 make 的过程中会被特殊处理：当命令执行的过程中断时，make 不会删除它们。而且如果目标的依赖文件是中间过程文件，同样这些文件不会被删除。                                                        |
| .INTERMEDIATE:         | 这个特殊目标的依赖文件在 make 执行时被作为中间文件对待。没有任何依赖文件的这个目标没有意义。                                                                                                                             |
| .SECONDARY:            | 这个特殊目标的依赖文件被作为中过程的文件对待。但是这些文件不会被删除。这个目标没有任何依赖文件的含义是：将所有的文件视为中间文件。                                                                                       |
| .IGNORE                | 这个目标的依赖文件忽略创建这个文件所执行命令的错误，给此目标指定命令是没有意义的。当此目标没有依赖文件时，将忽略所有命令执行的错误。                                                                                     |
| .DELETE_ON_ERROR:      | 如果在 Makefile 中存在特殊的目标 ".DELETE_ON_ERROR" ，make 在执行过程中，荣国规则的命令执行错误，将删除已经被修改的目标文件。                                                                                            |
| .LOW_RESOLUTION_TIME:  | 这个目标的依赖文件被 make 认为是低分辨率时间戳文件，给这个目标指定命令是没有意义的。通常的目标都是高分辨率时间戳。                                                                                                       |
| .SILENT:               | 出现在此目标 ".SILENT" 的依赖文件列表中的文件，make 在创建这些文件时，不打印出此文件所执行的命令。同样，给目标 "SILENT" 指定命令行是没有意义的。                                                                         |
| .EXPORT_ALL_VARIABLES: | 此目标应该作为一个简单的没有依赖的目标，它的功能是将之后的所有变量传递给子 make 进程。                                                                                                                                   |
| .NOTPARALLEL:          | Makefile 中如果出现这个特殊目标，则所有的命令按照串行的方式执行，即使是存在 make 的命令行参数 "-j" 。但在递归调用的子 make 进程中，命令行可以并行执行。此目标不应该有依赖文件，所有出现的依赖文件将会被忽略。            |

### 16.4 多规则目标

Makefile 中，一个文件可以作为多个规则的目标。这种情况时，以这个文件为目标的规则的所有依赖文件将会被合并成此目标一个依赖文件列表，当其中的任何一个依赖文件比目标更新时，make 将会执行特定的命令来重建这个目标。
对于一个多规则的目标，重建这个目标的命令只能出现在一个规则中。如果多个规则同时给出重建此目标的命令，make 将使用最后一个规则中所定义的命令，同时提示错误信息。某些情况，需要对相同的目标使用不同的规则中所定义的命令，我们需要使用另一种方式——双冒号规则来实现。

```
objects=foo.o bar.o
foo.o:defs.h
bar.o:defs.h test.h
$(objects):config.h
```

这样做的好处是：我们可以在源文件增加或者删除了包含的头文件以后不用修改已存在的 Makefile 的规则，只需要增加或者删除某一个 .o 文件依赖的头文件。这种方式很简单也很方便。

我们也可以通过一个变量来增加目标的依赖文件，使用 make 的命令行来指定某一个目标的依赖头文件，例如：
extradeps=
$(objects):$(exteradeps)
它的意思是：如果我们执 "make exteradeps=foo.h" 那么 "foo.h" 将作为所有的 .o 文件的依赖文件。当然如果只执行 "make" 的话，就没有指定任何文件作为 .o 文件的依赖文件。

## 17. 控制函数

Makefile 中提供了两个控制 make 运行方式的函数。其作用是当 make 执行过程中检测到某些错误时为用户提供消息，并且可以控制 make 执行过程是否继续。这两个函数是 "error" 和 "warning"

```Makefile
$(error TEXT...)
```

函数说明如下：

- 函数功能：产生致命错误，并提示 "TEXT..." 信息给用户，并退出 make 的执行。需要说明的是："error" 函数是在函数展开时（函数被调用时）才提示信息并结束 make 进程。因此如果函数出现在命令中或者一个递归的变量定义时，读取 Makefile 时不会出现错误。而只有包含 "error" 函数引用的命令被执行，或者定义中引用此函数的递归变量被展开时，才会提示知名信息 "TEXT..." 同时退出 make。
- 返回值：空
- 函数说明："error" 函数一般不出现在直接展开式的变量定义中，否则在 make 读取 Makefile 时将会提示致命错误。

```makefile
$(warning TEXT...)
```

函数说明如下：

- 函数功能：函数 "warning" 类似于函数 "error" ，区别在于它不会导致致命错误（make 不退出），而只是提示 "TEXT..."，make 的执行过程继续。
- 返回值：空
- 函数说明：用法和 "error" 类似，展开过程相同。

## 18. 常见的错误信息

make 执行过程中所产生错误并不都是致命的，特别是在命令行之前存在 `"-"`、或者 make 使用 "-k" 选项执行时。make 执行过程的致命错误都带有前缀字符串 `"***"`。

错误信息都有前缀，一种是执行程序名作为错误前缀（通常是 "make"）；另外一种是当 Makefile 本身存在语法错误无法被 make 解析并执行时，前缀包含了 Makefile 文件名和出现错误的行号。
在下述的错误列表中，省略了普通前缀：

```makefile
[FOO] Error NN
[FOO] signal description
```

这类错误并不是 make 的真正错误。它表示 make 检测到 make 所调用的作为执行命令的程序返回一个非零状态（Error NN），或者此命令程序以非正常方式退出（携带某种信号）。如果错误信息中没有附加 `"***" `字符串，则是子过程的调用失败，如果 Makefile 中此命令有前缀 "-"，make 会忽略这个错误。

```
missing separator. Stop.
missing separator (did you mean TAB instead of 8 spaces?). Stop.
```

错误的原因：不可识别的命令行，make 在读取 Makefile 过程中不能解析其中包含的内容。GNU make 在读取 Makefile 时根据各种分隔符（:, =, [TAB]字符等）来识别 Makefile 的每一行内容。这些错误意味着 make 不能发现一个合法的分隔符。

```
commands commence before first target. Stop.
missing rule before commands. Stop.
```

Makefile 可能是以命令行开始：以 [Tab] 字符开始，但不是一个合法的命令行（例如，一个变量的赋值）。命令行必须和规则一一对应。

```
No rule to make target 'XXX'.
No rule to make target 'XXX ', needed by 'yyy'.
```

无法为重建目标“XXX”找到合适的规则，包括明确规则和隐含规则。

```
No targets specified and no makefile found. Stop.
No targets. Stop.
```

第一个错误表示在命令行中没有指定需要重建的目标，并且 make 不能读入任何 Makefile 文件。第二个错误表示能够找到 Makefile 文件，但没有终极目标或者没有在命令行中指出需要重建的目标。这种情况下，make 什么也不做。

```
Makefile 'XXX' was not found.
Included makefile 'XXX' was not found.
```

没有使用 "-f" 指定 Makefile 文件，make 不能在当前目录下找到默认 Makefile（makefile 或者 GNUmakefile）。使用 "-f" 指定文件，但不能读取这个指定的 Makefile 文件。

```
warning: overriding commands for target 'XXX'
warning: ignoring old commands for target 'XXX'
```

对同一目标 "XXX" 存在一个以上的重建命令。GNU make 规定：当同一个文件作为多个规则的目标时，只能有一个规则定义重建它的命令（双冒号规则除外）。如果为一个目标多次指定了相同或者不同的命令，就会产生第一个告警；第二个告警信息说新指定的命令覆盖了上一次指定的命令。

```
Circular XXX <- YYY dependency dropped.
```

规则的依赖关系产生了循环：目标 "XXX" 的依赖文件为 "YYY"，而依赖 "YYY" 的依赖列表中又包含 "XXX"。

```
Recursive variable 'XXX' references itself (eventually). Stop.
```

make 的变量 "XXX"（递归展开式）在替换展开时，引用它自身。无论对于直接展开式变量（通过:=定义的）或追加定义（+=），这都是不允许的。

```
Unterminated variable reference. Stop.
```

变量或者函数引用语法不正确，没有使用完整的的括号（缺少左括号或者右括号）。

```
insufficient arguments to function 'XXX'. Stop.
```

函数 "XXX" 引用时参数数目不正确。函数缺少参数。

```
missing target pattern. Stop.
multiple target patterns. Stop.
target pattern contains no '%'. Stop.
mixed implicit and static pattern rules. Stop.
```

不正确的静态模式规则。

第一条错误的原因是：静态模式规则的目标段中没有模式目标；
第二条错误的原因是：静态模式规则的目标段中存在多个模式目标；
第三条错误的原因是：静态模式规则的目标段目标模式中没有包含模式字符“%”；
第四条错误的原因是：静态模式规则的三部分都包含了模式字符“%”。正确的应该是只有后两个才可以包含模式字符“%”。

```
warning: -jN forced in submake: disabling jobserver mode.
```

这一条告警和下条告警信息发生在：make 检测到递归的 make 调用时，可通信的子 make 进程出现并行处理的错误。递归执行的 make 的命令行参数中存在 "-jN" 参数（N 的值大于 1），在有些情况下可能导致此错误，例如：Makefile 中变量 "MAKE" 被赋值为 "make –j2"，并且递归调用的命令行中使用变量 "MAKE"。在这种情况下，被调用 make 进程不能和其它 make 进程进行通信，其只能简单的独立的并行处理两个任务”。

```
warning: jobserver unavailable: using -j1. Add '+' to parent make rule.
```

为了现实 make 进程之间的通信，上层 make 进程将传递信息给子 make 进程。在传递信息过程中可能存在这种情况，子 make 进程不是一个实际的 make 进程，而上层 make 却不能确定子进程是否是真实的 make 进程。它只是将所有信息传递下去。上层 make 采用正常的算法来决定这些。当出现这种情况，子进程只会接受父进程传递的部分有用的信息。子进程会产生该警告信息，之后按照其内建的顺序方式进行处理。
